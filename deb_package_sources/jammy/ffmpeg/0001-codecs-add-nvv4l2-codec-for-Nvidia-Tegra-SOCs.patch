From c98bf99fa126e0e22e6cb15c2fa8fc680a5f6473 Mon Sep 17 00:00:00 2001
From: CTCaer <ctcaer@gmail.com>
Date: Sat, 5 Mar 2022 03:27:27 +0000
Subject: [PATCH] codecs: add nvv4l2 codec for Nvidia Tegra SOCs

Use `--enable-nvv4l2` to enable it.

This Codec uses customized V4L2, called NVV4L2 that adds various features.
NVV4L2 uses the Tegra HW video engines NVDEC and NVENC.

Decoder features:
- Codecs: MPEG2, MPEG4, H264, HEVC, VP8, VP9
- Output: YUV420, NV12
- Low latency mode for realtime streaming by using `AV_CODEC_FLAG_LOW_DELAY`
- Higher throughput than original Nvidia specs and provided software.
  (Tegra X1: 4k@63, 1080p@265, 720p@439)

Encoder features:
- Codecs: H264, HEVC
- Output: YUV420, YUV444, NV12, P010
- Higher throughput than original Nvidia specs and provided software.
  (Tegra X1: 4k@60, 1080p@202, 720p@414)

- Options for H264:
  profile: baseline, main (default), high, high444
  level: 1.0 to 5.1 (default). (5.1 is L4T kernel limitation. Max is 6.2.)
  rc: cbr, vbr (default)
  lossless: off (default), on. (Sets profile to high444 and constant QP to 0)
  preset: default (medium), slow, medium (default), fast, ultrafast
  num_capture_buffers: 1 to 32. (Default: 10)
  AVCodec defaults: b: 5M, g: 50, all others unchanged.

- Options for HEVC:
  profile: main (default), main10
  tier: main (default), high
  level: 1.0 to 6.2 (default)
  rc: cbr, vbr (default)
  lossless: off (default), on. (Sets constant QP to 0)
  preset: default (medium), slow, medium (default), fast, ultrafast
  num_capture_buffers: 1 to 32. (Default: 10)
  AVCodec defaults: b: 5M, g: 50, all others unchanged.

Decoder to Encoder speed:
FPS are halved.

Some formats are supported from Tegra X1 and up.
For more, check the NVDEC/NVENC version support matrix.
---
 configure                     |   19 +
 fftools/ffmpeg_opt.c          |   80 +-
 fftools/ffplay.c              |   71 +
 libavcodec/Makefile           |    9 +
 libavcodec/allcodecs.c        |    8 +
 libavcodec/avcodec.c          |    3 -
 libavcodec/nvv4l2.c           |  867 ++++++++++++
 libavcodec/nvv4l2.h           |  339 +++++
 libavcodec/nvv4l2_dec.c       | 1288 +++++++++++++++++
 libavcodec/nvv4l2_enc.c       | 1482 ++++++++++++++++++++
 libavcodec/nvv4l2_ext_utils.h | 2475 +++++++++++++++++++++++++++++++++
 11 files changed, 6633 insertions(+), 8 deletions(-)
 create mode 100644 libavcodec/nvv4l2.c
 create mode 100644 libavcodec/nvv4l2.h
 create mode 100644 libavcodec/nvv4l2_dec.c
 create mode 100644 libavcodec/nvv4l2_enc.c
 create mode 100644 libavcodec/nvv4l2_ext_utils.h

diff --git a/configure b/configure
index 6409b94b65..38e8ef75f7 100755
--- a/configure
+++ b/configure
@@ -333,6 +333,7 @@ External library support:
   --enable-cuda-nvcc       enable Nvidia CUDA compiler [no]
   --disable-cuda-llvm      disable CUDA compilation using clang [autodetect]
   --disable-cuvid          disable Nvidia CUVID support [autodetect]
+  --enable-nvv4l2          enable Nvidia Tegra NVV4L2 support [no]
   --disable-d3d11va        disable Microsoft Direct3D 11 video acceleration code [autodetect]
   --disable-dxva2          disable Microsoft DirectX 9 video acceleration code [autodetect]
   --disable-ffnvcodec      disable dynamically linked Nvidia code [autodetect]
@@ -1843,6 +1844,7 @@ HWACCEL_AUTODETECT_LIBRARY_LIST="
     ffnvcodec
     nvdec
     nvenc
+    nvv4l2
     vaapi
     vdpau
     videotoolbox
@@ -3051,6 +3053,8 @@ qsvenc_select="qsv"
 qsvvpp_select="qsv"
 vaapi_encode_deps="vaapi"
 v4l2_m2m_deps="linux_videodev2_h sem_timedwait"
+nvv4l2_deps="libv4l2 pthreads linux_videodev2_h"
+nvv4l2_extralibs="-lnvbuf_utils"
 
 hwupload_cuda_filter_deps="ffnvcodec"
 scale_npp_filter_deps="ffnvcodec libnpp"
@@ -3066,6 +3070,9 @@ amf_deps_any="libdl LoadLibrary"
 nvenc_deps="ffnvcodec"
 nvenc_deps_any="libdl LoadLibrary"
 nvenc_encoder_deps="nvenc"
+h264_nvv4l2_encoder_deps="nvv4l2"
+h264_nvv4l2_decoder_deps="nvv4l2"
+h264_nvv4l2_decoder_select="h264_mp4toannexb_bsf"
 
 aac_mf_encoder_deps="mediafoundation"
 ac3_mf_encoder_deps="mediafoundation"
@@ -3098,6 +3105,9 @@ hevc_mediacodec_decoder_deps="mediacodec"
 hevc_mediacodec_decoder_select="hevc_mp4toannexb_bsf hevc_parser"
 hevc_mf_encoder_deps="mediafoundation"
 hevc_nvenc_encoder_deps="nvenc"
+hevc_nvv4l2_encoder_deps="nvv4l2"
+hevc_nvv4l2_decoder_deps="nvv4l2"
+hevc_nvv4l2_decoder_select="hevc_mp4toannexb_bsf"
 hevc_nvenc_encoder_select="atsc_a53"
 hevc_qsv_decoder_select="hevc_mp4toannexb_bsf qsvdec"
 hevc_qsv_encoder_select="hevcparse qsvenc"
@@ -3121,6 +3131,7 @@ mpeg2_crystalhd_decoder_select="crystalhd"
 mpeg2_cuvid_decoder_deps="cuvid"
 mpeg2_mmal_decoder_deps="mmal"
 mpeg2_mediacodec_decoder_deps="mediacodec"
+mpeg2_nvv4l2_decoder_deps="nvv4l2"
 mpeg2_qsv_decoder_select="qsvdec"
 mpeg2_qsv_encoder_select="qsvenc"
 mpeg2_vaapi_encoder_select="cbs_mpeg2 vaapi_encode"
@@ -3129,6 +3140,7 @@ mpeg4_crystalhd_decoder_select="crystalhd"
 mpeg4_cuvid_decoder_deps="cuvid"
 mpeg4_mediacodec_decoder_deps="mediacodec"
 mpeg4_mmal_decoder_deps="mmal"
+mpeg4_nvv4l2_decoder_deps="nvv4l2"
 mpeg4_omx_encoder_deps="omx"
 mpeg4_v4l2m2m_decoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
 mpeg4_v4l2m2m_encoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
@@ -3142,6 +3154,7 @@ vc1_qsv_decoder_select="qsvdec"
 vc1_v4l2m2m_decoder_deps="v4l2_m2m vc1_v4l2_m2m"
 vp8_cuvid_decoder_deps="cuvid"
 vp8_mediacodec_decoder_deps="mediacodec"
+vp8_nvv4l2_decoder_deps="nvv4l2"
 vp8_qsv_decoder_select="qsvdec"
 vp8_rkmpp_decoder_deps="rkmpp"
 vp8_vaapi_encoder_deps="VAEncPictureParameterBufferVP8"
@@ -3150,6 +3163,7 @@ vp8_v4l2m2m_decoder_deps="v4l2_m2m vp8_v4l2_m2m"
 vp8_v4l2m2m_encoder_deps="v4l2_m2m vp8_v4l2_m2m"
 vp9_cuvid_decoder_deps="cuvid"
 vp9_mediacodec_decoder_deps="mediacodec"
+vp9_nvv4l2_decoder_deps="nvv4l2"
 vp9_qsv_decoder_select="qsvdec"
 vp9_rkmpp_decoder_deps="rkmpp"
 vp9_vaapi_encoder_deps="VAEncPictureParameterBufferVP9"
@@ -3426,6 +3440,7 @@ kmsgrab_indev_deps="libdrm"
 lavfi_indev_deps="avfilter"
 libcdio_indev_deps="libcdio"
 libdc1394_indev_deps="libdc1394"
+nvv4l2_indev_deps="v4l2"
 openal_indev_deps="openal"
 opengl_outdev_deps="opengl"
 opengl_outdev_suggest="sdl2"
@@ -6783,6 +6798,10 @@ if enabled_any nvdec cuvid; then
     check_type "ffnvcodec/dynlink_cuda.h ffnvcodec/dynlink_cuviddec.h" "CUVIDAV1PICPARAMS"
 fi
 
+enabled nvv4l2 && add_ldflags '-L/usr/lib/aarch64-linux-gnu/tegra' \
+               && check_headers linux/videodev2.h \
+               && require_pkg_config libv4l2 libv4l2 libv4l2.h v4l2_ioctl
+
 enabled amf &&
     check_cpp_condition amf "AMF/core/Version.h" \
         "(AMF_VERSION_MAJOR << 48 | AMF_VERSION_MINOR << 32 | AMF_VERSION_RELEASE << 16 | AMF_VERSION_BUILD_NUM) >= 0x0001000400090000"
diff --git a/fftools/ffmpeg_opt.c b/fftools/ffmpeg_opt.c
index 807e783422..dd6cf9c290 100644
--- a/fftools/ffmpeg_opt.c
+++ b/fftools/ffmpeg_opt.c
@@ -769,14 +769,84 @@ static AVCodec *find_codec_or_die(const char *name, enum AVMediaType type, int e
 static const AVCodec *choose_decoder(OptionsContext *o, AVFormatContext *s, AVStream *st)
 {
     char *codec_name = NULL;
+#if CONFIG_NVV4L2
+    int nvv4l2_pix_fmt_ok;
+#endif
 
     MATCH_PER_STREAM_OPT(codec_names, str, codec_name, s, st);
-    if (codec_name) {
-        const AVCodec *codec = find_codec_or_die(codec_name, st->codecpar->codec_type, 0);
-        st->codecpar->codec_id = codec->id;
-        return codec;
-    } else
+
+#if CONFIG_NVV4L2
+    nvv4l2_pix_fmt_ok = st->codecpar->format == AV_PIX_FMT_NONE ||
+                        st->codecpar->format == AV_PIX_FMT_NV12 ||
+                        st->codecpar->format == AV_PIX_FMT_YUV420P;
+    if (st->codecpar->codec_id == AV_CODEC_ID_HEVC)
+        nvv4l2_pix_fmt_ok = st->codecpar->format == AV_PIX_FMT_YUV420P10LE ||
+                            st->codecpar->format == AV_PIX_FMT_P010 ||
+                            nvv4l2_pix_fmt_ok;
+
+    /* Force software decoding if codec name not defined and pixel format not supported. */
+    if (!codec_name && !nvv4l2_pix_fmt_ok) {
+        switch (st->codecpar->codec_id) {
+        case AV_CODEC_ID_H264:
+            codec_name = (char *)"h264";
+            break;
+        case AV_CODEC_ID_HEVC:
+            codec_name = (char *)"hevc";
+            break;
+        case AV_CODEC_ID_MPEG2VIDEO:
+            codec_name = (char *)"mpeg2video";
+            break;
+        case AV_CODEC_ID_MPEG4:
+            codec_name = (char *)"mpeg4";
+            break;
+        case AV_CODEC_ID_VP8:
+            codec_name = (char *)"vp8";
+            break;
+        case AV_CODEC_ID_VP9:
+            codec_name = (char *)"vp9";
+            break;
+        }
+    }
+#endif
+
+    if (!codec_name)
         return avcodec_find_decoder(st->codecpar->codec_id);
+
+#if CONFIG_NVV4L2
+    if (nvv4l2_pix_fmt_ok) {
+        /* Force hardware decoding if pixel format supported. */
+        if (strcmp(codec_name, "h264") == 0)
+            return avcodec_find_decoder(st->codecpar->codec_id);
+        else if (strcmp(codec_name, "hevc") == 0)
+            return avcodec_find_decoder(st->codecpar->codec_id);
+        else if (strcmp(codec_name, "mpeg2video") == 0)
+            return avcodec_find_decoder(st->codecpar->codec_id);
+        else if (strcmp(codec_name, "mpeg4") == 0)
+            return avcodec_find_decoder(st->codecpar->codec_id);
+        else if (strcmp(codec_name, "vp8") == 0)
+            return avcodec_find_decoder(st->codecpar->codec_id);
+        else if (strcmp(codec_name, "vp9") == 0)
+            return avcodec_find_decoder(st->codecpar->codec_id);
+    } else {
+        /* Force software decoding if pixel format not supported. */
+        if (strcmp(codec_name, "h264_nvv4l2") == 0)
+            codec_name = (char *)"h264";
+        else if (strcmp(codec_name, "hevc_nvv4l2") == 0)
+            codec_name = (char *)"hevc";
+        else if (strcmp(codec_name, "mpeg2video_nvv4l2") == 0)
+            codec_name = (char *)"mpeg2video";
+        else if (strcmp(codec_name, "mpeg4_nvv4l2") == 0)
+            codec_name = (char *)"mpeg4";
+        else if (strcmp(codec_name, "vp8_nvv4l2") == 0)
+            codec_name = (char *)"vp8";
+        else if (strcmp(codec_name, "vp9_nvv4l2") == 0)
+            codec_name = (char *)"vp9";
+    }
+#endif
+
+    const AVCodec *codec = find_codec_or_die(codec_name, st->codecpar->codec_type, 0);
+    st->codecpar->codec_id = codec->id;
+    return codec;
 }
 
 /* Add all the streams from the given input file to the global
diff --git a/fftools/ffplay.c b/fftools/ffplay.c
index e14c800b8f..635cfef615 100644
--- a/fftools/ffplay.c
+++ b/fftools/ffplay.c
@@ -2581,6 +2581,9 @@ static int stream_component_open(VideoState *is, int stream_index)
     int64_t channel_layout;
     int ret = 0;
     int stream_lowres = lowres;
+#if CONFIG_NVV4L2
+    int nvv4l2_pix_fmt_ok;
+#endif
 
     if (stream_index < 0 || stream_index >= ic->nb_streams)
         return -1;
@@ -2601,6 +2604,74 @@ static int stream_component_open(VideoState *is, int stream_index)
         case AVMEDIA_TYPE_SUBTITLE: is->last_subtitle_stream = stream_index; forced_codec_name = subtitle_codec_name; break;
         case AVMEDIA_TYPE_VIDEO   : is->last_video_stream    = stream_index; forced_codec_name =    video_codec_name; break;
     }
+
+#if CONFIG_NVV4L2
+    /* Reset requested decoder in order to enforce NVV4L2 if possible. */
+    nvv4l2_pix_fmt_ok = avctx->pix_fmt == AV_PIX_FMT_NONE ||
+                        avctx->pix_fmt == AV_PIX_FMT_NV12 ||
+                        avctx->pix_fmt == AV_PIX_FMT_YUV420P;
+    if (avctx->codec_id == AV_CODEC_ID_HEVC)
+        nvv4l2_pix_fmt_ok = avctx->pix_fmt == AV_PIX_FMT_YUV420P10LE ||
+                            avctx->pix_fmt == AV_PIX_FMT_P010 ||
+                            nvv4l2_pix_fmt_ok;
+
+    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO && forced_codec_name) {
+        if (nvv4l2_pix_fmt_ok) {
+            /* Force hardware decoding if pixel format supported. */
+            if (strcmp(forced_codec_name, "h264") == 0)
+                forced_codec_name = NULL;
+            else if (strcmp(forced_codec_name, "hevc") == 0)
+                forced_codec_name = NULL;
+            else if (strcmp(forced_codec_name, "mpeg2video") == 0)
+                forced_codec_name = NULL;
+            else if (strcmp(forced_codec_name, "mpeg4") == 0)
+                forced_codec_name = NULL;
+            else if (strcmp(forced_codec_name, "vp8") == 0)
+                forced_codec_name = NULL;
+            else if (strcmp(forced_codec_name, "vp9") == 0)
+                forced_codec_name = NULL;
+        } else {
+            /* Force software decoding if pixel format not supported. */
+            if (strcmp(forced_codec_name, "h264_nvv4l2") == 0)
+                forced_codec_name = (char *)"h264";
+            else if (strcmp(forced_codec_name, "hevc_nvv4l2") == 0)
+                forced_codec_name = (char *)"hevc";
+            else if (strcmp(forced_codec_name, "mpeg2video_nvv4l2") == 0)
+                forced_codec_name = (char *)"mpeg2video";
+            else if (strcmp(forced_codec_name, "mpeg4_nvv4l2") == 0)
+                forced_codec_name = (char *)"mpeg4";
+            else if (strcmp(forced_codec_name, "vp8_nvv4l2") == 0)
+                forced_codec_name = (char *)"vp8";
+            else if (strcmp(forced_codec_name, "vp9_nvv4l2") == 0)
+                forced_codec_name = (char *)"vp9";
+        }
+    }
+
+    /* Force software decoding if codec name not defined and pixel format not supported. */
+    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO && !forced_codec_name && !nvv4l2_pix_fmt_ok) {
+        switch (avctx->codec_id) {
+        case AV_CODEC_ID_H264:
+            forced_codec_name = (char *)"h264";
+            break;
+        case AV_CODEC_ID_HEVC:
+            forced_codec_name = (char *)"hevc";
+            break;
+        case AV_CODEC_ID_MPEG2VIDEO:
+            forced_codec_name = (char *)"mpeg2video";
+            break;
+        case AV_CODEC_ID_MPEG4:
+            forced_codec_name = (char *)"mpeg4";
+            break;
+        case AV_CODEC_ID_VP8:
+            forced_codec_name = (char *)"vp8";
+            break;
+        case AV_CODEC_ID_VP9:
+            forced_codec_name = (char *)"vp9";
+            break;
+        }
+    }
+#endif
+
     if (forced_codec_name)
         codec = avcodec_find_decoder_by_name(forced_codec_name);
     if (!codec) {
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index b3d284d7d0..5c9238f8a1 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -132,6 +132,7 @@ OBJS-$(CONFIG_MPEGVIDEOENC)            += mpegvideo_enc.o mpeg12data.o  \
                                           motion_est.o ratecontrol.o    \
                                           mpegvideoencdsp.o
 OBJS-$(CONFIG_MSS34DSP)                += mss34dsp.o
+OBJS-$(CONFIG_NVV4L2)                  += nvv4l2.o
 OBJS-$(CONFIG_PIXBLOCKDSP)             += pixblockdsp.o
 OBJS-$(CONFIG_QPELDSP)                 += qpeldsp.o
 OBJS-$(CONFIG_QSV)                     += qsv.o
@@ -371,12 +372,14 @@ OBJS-$(CONFIG_H264_DECODER)            += h264dec.o h264_cabac.o h264_cavlc.o \
                                           h264_slice.o h264data.o
 OBJS-$(CONFIG_H264_AMF_ENCODER)        += amfenc_h264.o
 OBJS-$(CONFIG_H264_CUVID_DECODER)      += cuviddec.o
+OBJS-$(CONFIG_H264_NVV4L2_DECODER)     += nvv4l2_dec.o
 OBJS-$(CONFIG_H264_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_H264_MF_ENCODER)         += mfenc.o mf_utils.o
 OBJS-$(CONFIG_H264_MMAL_DECODER)       += mmaldec.o
 OBJS-$(CONFIG_H264_NVENC_ENCODER)      += nvenc.o nvenc_h264.o
 OBJS-$(CONFIG_NVENC_ENCODER)           += nvenc.o nvenc_h264.o
 OBJS-$(CONFIG_NVENC_H264_ENCODER)      += nvenc.o nvenc_h264.o
+OBJS-$(CONFIG_H264_NVV4L2_ENCODER)     += nvv4l2_enc.o
 OBJS-$(CONFIG_H264_OMX_ENCODER)        += omx.o
 OBJS-$(CONFIG_H264_QSV_DECODER)        += qsvdec.o
 OBJS-$(CONFIG_H264_QSV_ENCODER)        += qsvenc_h264.o
@@ -394,6 +397,7 @@ OBJS-$(CONFIG_HEVC_DECODER)            += hevcdec.o hevc_mvs.o \
                                           hevcdsp.o hevc_filter.o hevc_data.o
 OBJS-$(CONFIG_HEVC_AMF_ENCODER)        += amfenc_hevc.o
 OBJS-$(CONFIG_HEVC_CUVID_DECODER)      += cuviddec.o
+OBJS-$(CONFIG_HEVC_NVV4L2_DECODER)     += nvv4l2_dec.o
 OBJS-$(CONFIG_HEVC_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_HEVC_MF_ENCODER)         += mfenc.o mf_utils.o
 OBJS-$(CONFIG_HEVC_NVENC_ENCODER)      += nvenc.o nvenc_hevc.o
@@ -404,6 +408,7 @@ OBJS-$(CONFIG_HEVC_QSV_ENCODER)        += qsvenc_hevc.o hevc_ps_enc.o       \
 OBJS-$(CONFIG_HEVC_RKMPP_DECODER)      += rkmppdec.o
 OBJS-$(CONFIG_HEVC_VAAPI_ENCODER)      += vaapi_encode_h265.o h265_profile_level.o
 OBJS-$(CONFIG_HEVC_V4L2M2M_DECODER)    += v4l2_m2m_dec.o
+OBJS-$(CONFIG_HEVC_NVV4L2_ENCODER)     += nvv4l2_enc.o
 OBJS-$(CONFIG_HEVC_V4L2M2M_ENCODER)    += v4l2_m2m_enc.o
 OBJS-$(CONFIG_HNM4_VIDEO_DECODER)      += hnm4video.o
 OBJS-$(CONFIG_HQ_HQA_DECODER)          += hq_hqa.o hq_hqadata.o hq_hqadsp.o \
@@ -494,12 +499,14 @@ OBJS-$(CONFIG_MPEG2_QSV_ENCODER)       += qsvenc_mpeg2.o
 OBJS-$(CONFIG_MPEG2VIDEO_DECODER)      += mpeg12dec.o mpeg12.o mpeg12data.o
 OBJS-$(CONFIG_MPEG2VIDEO_ENCODER)      += mpeg12enc.o mpeg12.o
 OBJS-$(CONFIG_MPEG2_CUVID_DECODER)     += cuviddec.o
+OBJS-$(CONFIG_MPEG2_NVV4L2_DECODER)    += nvv4l2_dec.o
 OBJS-$(CONFIG_MPEG2_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_MPEG2_VAAPI_ENCODER)     += vaapi_encode_mpeg2.o
 OBJS-$(CONFIG_MPEG2_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
 OBJS-$(CONFIG_MPEG4_DECODER)           += xvididct.o
 OBJS-$(CONFIG_MPEG4_ENCODER)           += mpeg4videoenc.o
 OBJS-$(CONFIG_MPEG4_CUVID_DECODER)     += cuviddec.o
+OBJS-$(CONFIG_MPEG4_NVV4L2_DECODER)    += nvv4l2_dec.o
 OBJS-$(CONFIG_MPEG4_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_MPEG4_OMX_ENCODER)       += omx.o
 OBJS-$(CONFIG_MPEG4_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
@@ -714,6 +721,7 @@ OBJS-$(CONFIG_VP6_DECODER)             += vp6.o vp56.o vp56data.o \
 OBJS-$(CONFIG_VP7_DECODER)             += vp8.o vp56rac.o
 OBJS-$(CONFIG_VP8_DECODER)             += vp8.o vp56rac.o
 OBJS-$(CONFIG_VP8_CUVID_DECODER)       += cuviddec.o
+OBJS-$(CONFIG_VP8_NVV4L2_DECODER)      += nvv4l2_dec.o
 OBJS-$(CONFIG_VP8_MEDIACODEC_DECODER)  += mediacodecdec.o
 OBJS-$(CONFIG_VP8_QSV_DECODER)         += qsvdec.o
 OBJS-$(CONFIG_VP8_RKMPP_DECODER)       += rkmppdec.o
@@ -724,6 +732,7 @@ OBJS-$(CONFIG_VP9_DECODER)             += vp9.o vp9data.o vp9dsp.o vp9lpf.o vp9r
                                           vp9block.o vp9prob.o vp9mvs.o vp56rac.o \
                                           vp9dsp_8bpp.o vp9dsp_10bpp.o vp9dsp_12bpp.o
 OBJS-$(CONFIG_VP9_CUVID_DECODER)       += cuviddec.o
+OBJS-$(CONFIG_VP9_NVV4L2_DECODER)      += nvv4l2_dec.o
 OBJS-$(CONFIG_VP9_MEDIACODEC_DECODER)  += mediacodecdec.o
 OBJS-$(CONFIG_VP9_RKMPP_DECODER)       += rkmppdec.o
 OBJS-$(CONFIG_VP9_VAAPI_ENCODER)       += vaapi_encode_vp9.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 2e9a3581de..a828e43cfd 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -141,6 +141,8 @@ extern AVCodec ff_h263i_decoder;
 extern AVCodec ff_h263p_encoder;
 extern AVCodec ff_h263p_decoder;
 extern AVCodec ff_h263_v4l2m2m_decoder;
+extern AVCodec ff_h264_nvv4l2_encoder;
+extern AVCodec ff_h264_nvv4l2_decoder;
 extern AVCodec ff_h264_decoder;
 extern AVCodec ff_h264_crystalhd_decoder;
 extern AVCodec ff_h264_v4l2m2m_decoder;
@@ -150,6 +152,8 @@ extern AVCodec ff_h264_qsv_decoder;
 extern AVCodec ff_h264_rkmpp_decoder;
 extern AVCodec ff_hap_encoder;
 extern AVCodec ff_hap_decoder;
+extern AVCodec ff_hevc_nvv4l2_encoder;
+extern AVCodec ff_hevc_nvv4l2_decoder;
 extern AVCodec ff_hevc_decoder;
 extern AVCodec ff_hevc_qsv_decoder;
 extern AVCodec ff_hevc_rkmpp_decoder;
@@ -194,8 +198,10 @@ extern AVCodec ff_mobiclip_decoder;
 extern AVCodec ff_motionpixels_decoder;
 extern AVCodec ff_mpeg1video_encoder;
 extern AVCodec ff_mpeg1video_decoder;
+extern AVCodec ff_mpeg2_nvv4l2_decoder;
 extern AVCodec ff_mpeg2video_encoder;
 extern AVCodec ff_mpeg2video_decoder;
+extern AVCodec ff_mpeg4_nvv4l2_decoder;
 extern AVCodec ff_mpeg4_encoder;
 extern AVCodec ff_mpeg4_decoder;
 extern AVCodec ff_mpeg4_crystalhd_decoder;
@@ -356,9 +362,11 @@ extern AVCodec ff_vp6_decoder;
 extern AVCodec ff_vp6a_decoder;
 extern AVCodec ff_vp6f_decoder;
 extern AVCodec ff_vp7_decoder;
+extern AVCodec ff_vp8_nvv4l2_decoder;
 extern AVCodec ff_vp8_decoder;
 extern AVCodec ff_vp8_rkmpp_decoder;
 extern AVCodec ff_vp8_v4l2m2m_decoder;
+extern AVCodec ff_vp9_nvv4l2_decoder;
 extern AVCodec ff_vp9_decoder;
 extern AVCodec ff_vp9_rkmpp_decoder;
 extern AVCodec ff_vp9_v4l2m2m_decoder;
diff --git a/libavcodec/avcodec.c b/libavcodec/avcodec.c
index e572e9533d..170aeed72e 100644
--- a/libavcodec/avcodec.c
+++ b/libavcodec/avcodec.c
@@ -428,9 +428,6 @@ int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *code
             avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));
 #endif
     }
-    if (codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {
-        av_assert0(*(const AVClass **)avctx->priv_data == codec->priv_class);
-    }
 
 end:
     unlock_avcodec(codec);
diff --git a/libavcodec/nvv4l2.c b/libavcodec/nvv4l2.c
new file mode 100644
index 0000000000..44a825c8c2
--- /dev/null
+++ b/libavcodec/nvv4l2.c
@@ -0,0 +1,867 @@
+/*
+ * Copyright (c) 2021-2022, CTCaer <ctcaer@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdatomic.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include "internal.h"
+#include "libavutil/log.h"
+
+#include "nvv4l2.h"
+
+uint32_t nvv4l2_map_nvcodec_type(NvCodingType nv_codec_type)
+{
+    uint32_t v4l2_pix_fmt;
+    switch (nv_codec_type) {
+    case NvVideoCodec_H264:
+        v4l2_pix_fmt = V4L2_PIX_FMT_H264;
+        break;
+    case NvVideoCodec_HEVC:
+        v4l2_pix_fmt = V4L2_PIX_FMT_H265;
+        break;
+    case NvVideoCodec_MPEG2:
+        v4l2_pix_fmt = V4L2_PIX_FMT_MPEG2;
+        break;
+    case NvVideoCodec_MPEG4:
+        v4l2_pix_fmt = V4L2_PIX_FMT_MPEG4;
+        break;
+    case NvVideoCodec_VP8:
+        v4l2_pix_fmt = V4L2_PIX_FMT_VP8;
+        break;
+    case NvVideoCodec_VP9:
+        v4l2_pix_fmt = V4L2_PIX_FMT_VP9;
+        break;
+    default:
+        v4l2_pix_fmt = V4L2_PIX_FMT_H264;
+        break;
+    }
+
+    return v4l2_pix_fmt;
+}
+
+int nvv4l2_pool_idx_next(nvv4l2_ctx_t *ctx, NvQueues *q)
+{
+    int index;
+    if (q->capacity < NV_MAX_BUFFERS) {
+        index = q->back;
+    } else {
+        index = -1;
+    }
+    return index;
+}
+
+void nvv4l2_pool_push(nvv4l2_ctx_t *ctx, NvQueues *q)
+{
+    if (q->capacity < NV_MAX_BUFFERS) {
+        q->back = (q->back + 1) % NV_MAX_BUFFERS;
+        atomic_fetch_add(&q->capacity, 1);
+    } else {
+        av_log(ctx->avctx, AV_LOG_ERROR, "Queue already full!\n");
+    }
+}
+
+int nvv4l2_pool_pop(nvv4l2_ctx_t *ctx, NvQueues *q)
+{
+    int index = q->front;
+    if (q->capacity != 0) {
+        q->front = (q->front + 1) % NV_MAX_BUFFERS;
+        atomic_fetch_sub(&q->capacity, 1);
+    } else {
+        av_log(ctx->avctx, AV_LOG_ERROR, "Queue already empty!");
+    }
+    return index;
+}
+
+int
+nvv4l2_create_bufferfmt(NvBuffer *buffer, enum v4l2_buf_type buf_type,
+                     enum v4l2_memory memory_type, uint32_t n_planes,
+                     NvBufferPlaneFormat *fmt, uint32_t index)
+{
+    buffer->mapped = false;
+    buffer->buf_type = buf_type;
+    buffer->memory_type = memory_type;
+    buffer->index = index;
+    buffer->n_planes = n_planes;
+
+    memset(buffer->planes, 0, sizeof(NvBufferPlane));
+    for (uint32_t i = 0; i < buffer->n_planes; i++) {
+        buffer->planes[i].fd = -1;
+        buffer->planes[i].fmt = fmt[i];
+    }
+    return 0;
+}
+
+int
+nvv4l2_map_out(nvv4l2_ctx_t *ctx, struct v4l2_buffer *v4l2_buf,
+               enum v4l2_buf_type buf_type, enum v4l2_memory mem_type,
+               int dma_fd)
+{
+    int ret;
+    NvBuffer *buffer;
+    NvBufferParams params;
+    unsigned char *data;
+    pthread_mutex_lock(&ctx->queue_lock);
+
+    if (buf_type == ctx->op_buf_type)
+        buffer = ctx->op_buffers[v4l2_buf->index];
+    else if (buf_type == ctx->cp_buf_type)
+        buffer = ctx->cp_buffers[v4l2_buf->index];
+
+    switch (mem_type) {
+    case V4L2_MEMORY_DMABUF:
+        ret = NvBufferGetParams(dma_fd, &params);
+        if(ret) {
+            av_log(ctx->avctx, AV_LOG_ERROR, "GetParams failed!\n");
+            pthread_mutex_unlock(&ctx->queue_lock);
+            return ret;
+        }
+        for (uint32_t i = 0; i < buffer->n_planes; i++) {
+            buffer->planes[i].fd = dma_fd;
+            v4l2_buf->m.planes[i].m.fd = dma_fd;
+            buffer->planes[i].mem_offset = params.offset[i];
+            ret = NvBufferMemMap(dma_fd, i, NvBufferMem_Read_Write,
+                                 (void **)&data);
+            if (ret) {
+                ctx->in_error = true;
+                av_log(ctx->avctx, AV_LOG_ERROR,
+                       "Error while Mapping buffer!\n");
+                pthread_mutex_unlock(&ctx->queue_lock);
+                return ret;
+            }
+            buffer->planes[i].data = data;
+        }
+        break;
+    default:
+        pthread_mutex_unlock(&ctx->queue_lock);
+        return -1;
+    }
+    pthread_mutex_unlock(&ctx->queue_lock);
+
+    return ret;
+}
+
+int
+nvv4l2_unmap_out(nvv4l2_ctx_t *ctx, int index, enum v4l2_buf_type buf_type,
+                 enum v4l2_memory mem_type, int dma_fd)
+{
+    int ret = 0;
+    NvBuffer *buffer;
+    pthread_mutex_lock(&ctx->queue_lock);
+
+    if (buf_type == ctx->op_buf_type)
+        buffer = ctx->op_buffers[index];
+    else if (buf_type == ctx->cp_buf_type)
+        buffer = ctx->cp_buffers[index];
+
+    switch (mem_type) {
+    case V4L2_MEMORY_DMABUF:
+        for (uint32_t i = 0; i < buffer->n_planes; i++) {
+            ret = NvBufferMemUnMap(dma_fd, i, (void **)&buffer->planes[i].data);
+            if (ret) {
+                ctx->in_error = true;
+                av_log(ctx->avctx, AV_LOG_ERROR,
+                       "Error while Unmapping buffer!\n");
+                pthread_mutex_unlock(&ctx->queue_lock);
+                return ret;
+            }
+        }
+        break;
+    default:
+        pthread_mutex_unlock(&ctx->queue_lock);
+        return -1;
+    }
+    pthread_mutex_unlock(&ctx->queue_lock);
+
+    return ret;
+}
+
+int nvv4l2_allocate_memory(nvv4l2_ctx_t *ctx, NvBuffer *buffer)
+{
+     for (uint32_t i = 0; i < buffer->n_planes; i++) {
+        buffer->planes[i].length = NVMAX(buffer->planes[i].fmt.sizeimage,
+                                         buffer->planes[i].fmt.width *
+                                          buffer->planes[i].fmt.bytesperpixel *
+                                          buffer->planes[i].fmt.height);
+        buffer->planes[i].data =
+                (unsigned char *)NVMALLOC(sizeof(unsigned char) *
+                                        buffer->planes[i].length);
+        if (buffer->planes[i].data == NULL) {
+            av_log(ctx->avctx, AV_LOG_ERROR,
+                   "Could not allocate buffer %d plane %d!\n",
+                   buffer->index, i);
+            return -1;
+        }
+    }
+    return 0;
+}
+
+int nvv4l2_map(nvv4l2_ctx_t *ctx, NvBuffer *buffer)
+{
+    if (buffer->memory_type != V4L2_MEMORY_MMAP) {
+        av_log(ctx->avctx, AV_LOG_ERROR,
+               "Buffer type %d can't be mapped!\n", buffer->memory_type);
+        return -1;
+    }
+
+    if (buffer->mapped) {
+        av_log(ctx->avctx, AV_LOG_VERBOSE, "Buffer %d already mapped!\n",
+               buffer->index);
+        return 0;
+    }
+
+    for (uint32_t i = 0; i < buffer->n_planes; i++) {
+        if (buffer->planes[i].fd == -1) {
+            return -1;
+        }
+
+        buffer->planes[i].data =
+            (unsigned char *)mmap(NULL, buffer-> planes[i].length,
+                                         PROT_READ | PROT_WRITE, MAP_SHARED,
+                                         buffer->planes[i].fd,
+                                         buffer->planes
+                                         [i].mem_offset);
+        if (buffer->planes[i].data == MAP_FAILED) {
+            av_log(ctx->avctx, AV_LOG_ERROR,
+                   "Could not map buffer %d plane %d!\n", buffer->index, i);
+            return -1;
+        }
+    }
+    buffer->mapped = true;
+    return 0;
+}
+
+void nvv4l2_unmap(nvv4l2_ctx_t *ctx, NvBuffer *buffer)
+{
+    if (buffer->memory_type != V4L2_MEMORY_MMAP || !buffer->mapped) {
+        av_log(ctx->avctx, AV_LOG_VERBOSE,
+            "Cannot unmap Buffer %d Only mapped MMAP buffer can be unmapped\n",
+            buffer->index);
+        return;
+    }
+
+    for (uint32_t i = 0; i < buffer->n_planes; i++) {
+        if (buffer->planes[i].data) {
+            munmap(buffer->planes[i].data, buffer->planes[i].length);
+        }
+        buffer->planes[i].data = NULL;
+    }
+    buffer->mapped = false;
+}
+
+void nvv4l2_destroyBuffer(nvv4l2_ctx_t *ctx, NvBuffer *buffer)
+{
+    if (buffer->mapped) {
+        nvv4l2_unmap(ctx, buffer);
+    }
+}
+
+int
+nvv4l2_query_buffer(nvv4l2_ctx_t *ctx, enum v4l2_buf_type buf_type,
+                    enum v4l2_memory memory_type, uint32_t num_planes,
+                    uint32_t index)
+{
+    struct v4l2_buffer v4l2_buf;
+    struct v4l2_plane planes[NV_MAX_PLANES];
+    NvBuffer *buffer;
+    int ret;
+    uint32_t j;
+
+    memset(&v4l2_buf, 0, sizeof(struct v4l2_buffer));
+    memset(planes, 0, sizeof(planes));
+    v4l2_buf.index = index;
+    v4l2_buf.type = buf_type;
+    v4l2_buf.memory = memory_type;
+    v4l2_buf.m.planes = planes;
+    v4l2_buf.length = num_planes;
+
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_QUERYBUF, &v4l2_buf);
+    if (ret) {
+        av_log(ctx->avctx, AV_LOG_ERROR, "Error in QueryBuf!\n");
+    } else {
+        if (buf_type == ctx->op_buf_type) {
+            buffer = ctx->op_buffers[index];
+        } else if (buf_type == ctx->cp_buf_type) {
+            buffer = ctx->cp_buffers[index];
+        }
+
+        for (j = 0; j < v4l2_buf.length; j++) {
+            buffer->planes[j].length = v4l2_buf.m.planes[j].length;
+            buffer->planes[j].mem_offset =
+                v4l2_buf.m.planes[j].m.mem_offset;
+        }
+    }
+
+    return ret;
+}
+
+int
+nvv4l2_export_buffer(nvv4l2_ctx_t *ctx, enum v4l2_buf_type buf_type,
+                     uint32_t num_planes, uint32_t index)
+{
+    struct v4l2_exportbuffer expbuf;
+    NvBuffer *buffer;
+    int ret;
+
+    memset(&expbuf, 0, sizeof(expbuf));
+    expbuf.type = buf_type;
+    expbuf.index = index;
+
+    for (uint32_t i = 0; i < num_planes; i++) {
+        expbuf.plane = i;
+        ret = v4l2_ioctl(ctx->fd, VIDIOC_EXPBUF, &expbuf);
+        if (ret) {
+            av_log(ctx->avctx, AV_LOG_ERROR, "Error in ExportBuf!\n");
+        }
+        else {
+            if (buf_type == ctx->op_buf_type) {
+                buffer = ctx->op_buffers[index];
+            } else if (buf_type == ctx->cp_buf_type) {
+                buffer = ctx->cp_buffers[index];
+            }
+            buffer->planes[i].fd = expbuf.fd;
+        }
+    }
+    return 0;
+}
+
+int
+nvv4l2_fill_buffer_plane_format(nvv4l2_ctx_t *ctx,
+                                uint32_t *num_planes,
+                                NvBufferPlaneFormat *planefmts,
+                                uint32_t width, uint32_t height,
+                                uint32_t pixfmt)
+{
+    switch (pixfmt) {
+    case V4L2_PIX_FMT_YUV444M:
+        *num_planes = 3;
+
+        planefmts[0].width = width;
+        planefmts[1].width = width;
+        planefmts[2].width = width;
+
+        planefmts[0].height = height;
+        planefmts[1].height = height;
+        planefmts[2].height = height;
+
+        planefmts[0].bytesperpixel = 1;
+        planefmts[1].bytesperpixel = 1;
+        planefmts[2].bytesperpixel = 1;
+        break;
+    case V4L2_PIX_FMT_YUV420M:
+        *num_planes = 3;
+
+        planefmts[0].width = width;
+        planefmts[1].width = width / 2;
+        planefmts[2].width = width / 2;
+
+        planefmts[0].height = height;
+        planefmts[1].height = height / 2;
+        planefmts[2].height = height / 2;
+
+        planefmts[0].bytesperpixel = 1;
+        planefmts[1].bytesperpixel = 1;
+        planefmts[2].bytesperpixel = 1;
+        break;
+    case V4L2_PIX_FMT_NV12M:
+        *num_planes = 2;
+
+        planefmts[0].width = width;
+        planefmts[1].width = width / 2;
+
+        planefmts[0].height = height;
+        planefmts[1].height = height / 2;
+
+        planefmts[0].bytesperpixel = 1;
+        planefmts[1].bytesperpixel = 2;
+        break;
+    case V4L2_PIX_FMT_P010M:
+        *num_planes = 2;
+
+        planefmts[0].width = width;
+        planefmts[1].width = width / 2;
+
+        planefmts[0].height = height;
+        planefmts[1].height = height / 2;
+
+        planefmts[0].bytesperpixel = 2;
+        planefmts[1].bytesperpixel = 4;
+        break;
+    default:
+        av_log(ctx->avctx, AV_LOG_ERROR, "Unsupported pixel format!");
+        return -1;
+    }
+
+    return 0;
+}
+
+int
+nvv4l2_dq_event(nvv4l2_ctx_t *ctx, struct v4l2_event *event,
+                uint32_t max_wait_ms)
+{
+    int ret;
+    do {
+        ret = v4l2_ioctl(ctx->fd, VIDIOC_DQEVENT, event);
+
+        if (errno != EAGAIN) {
+            break;
+        } else if (max_wait_ms-- == 0) {
+            break;
+        } else {
+            usleep(1000);
+        }
+    }
+    while (ret && (ctx->op_streamon || ctx->cp_streamon));
+
+    return ret;
+}
+
+int
+nvv4l2_dq_buffer(nvv4l2_ctx_t *ctx, struct v4l2_buffer *v4l2_buf,
+                 NvBuffer **buffer, enum v4l2_buf_type buf_type,
+                 enum v4l2_memory memory_type, uint32_t num_retries)
+{
+    int ret;
+    bool is_in_error = false;
+    v4l2_buf->type = buf_type;
+    v4l2_buf->memory = memory_type;
+    do {
+        ret = v4l2_ioctl(ctx->fd, VIDIOC_DQBUF, v4l2_buf);
+        if (ret == 0) {
+            pthread_mutex_lock(&ctx->queue_lock);
+            switch (v4l2_buf->type) {
+            case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
+                if (buffer)
+                    *buffer = ctx->op_buffers[v4l2_buf->index];
+                for (uint32_t i = 0;
+                     i < ctx->op_buffers[v4l2_buf->index]->n_planes; i++) {
+                    ctx->op_buffers[v4l2_buf->index]->planes[i].bytesused =
+                        v4l2_buf->m.planes[i].bytesused;
+                }
+                ctx->num_queued_op_buffers--;
+                break;
+
+            case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+                if (buffer)
+                    *buffer = ctx->cp_buffers[v4l2_buf->index];
+                for (uint32_t i = 0;
+                     i < ctx->cp_buffers[v4l2_buf->index]->n_planes; i++) {
+                    ctx->cp_buffers[v4l2_buf->index]->planes[i].bytesused =
+                        v4l2_buf->m.planes[i].bytesused;
+                }
+                ctx->num_queued_cp_buffers--;
+                break;
+
+            default:
+                av_log(ctx->avctx, AV_LOG_ERROR, "Invalid buffer type!\n");
+            }
+            pthread_cond_broadcast(&ctx->queue_cond);
+            pthread_mutex_unlock(&ctx->queue_lock);
+        } else if (errno == EAGAIN) {
+            pthread_mutex_lock(&ctx->queue_lock);
+            if (v4l2_buf->flags & V4L2_BUF_FLAG_LAST) {
+                pthread_mutex_unlock(&ctx->queue_lock);
+                break;
+            }
+            pthread_mutex_unlock(&ctx->queue_lock);
+
+            if (num_retries-- == 0) {
+                av_log(ctx->avctx, AV_LOG_VERBOSE, "Resource unavailable!\n");
+                break;
+            }
+        } else {
+            is_in_error = true;
+            break;
+        }
+    }
+    while (ret && !is_in_error);
+
+    return ret;
+}
+
+int
+nvv4l2_q_buffer(nvv4l2_ctx_t *ctx, struct v4l2_buffer *v4l2_buf,
+                NvBuffer *buffer, enum v4l2_buf_type buf_type,
+                enum v4l2_memory memory_type, int num_planes)
+{
+    int ret;
+
+    pthread_mutex_lock(&ctx->queue_lock);
+
+    if (!buffer && buf_type == ctx->op_buf_type)
+        buffer = ctx->op_buffers[v4l2_buf->index];
+    else if (!buffer && buf_type == ctx->cp_buf_type)
+        buffer = ctx->cp_buffers[v4l2_buf->index];
+
+    v4l2_buf->type = buf_type;
+    v4l2_buf->memory = memory_type;
+    v4l2_buf->length = num_planes;
+
+    switch (memory_type) {
+    case V4L2_MEMORY_USERPTR:
+        for (uint32_t i = 0; i < buffer->n_planes; i++) {
+            v4l2_buf->m.planes[i].m.userptr =
+                (unsigned long) buffer->planes[i].data;
+            v4l2_buf->m.planes[i].bytesused = buffer->planes[i].bytesused;
+        }
+        break;
+    case V4L2_MEMORY_MMAP:
+        for (uint32_t i = 0; i < buffer->n_planes; i++) {
+            v4l2_buf->m.planes[i].bytesused = buffer->planes[i].bytesused;
+        }
+        break;
+
+    case V4L2_MEMORY_DMABUF:
+        break;
+
+    default:
+        pthread_cond_broadcast(&ctx->queue_cond);
+        pthread_mutex_unlock(&ctx->queue_lock);
+        return -1;
+    }
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_QBUF, v4l2_buf);
+
+    if (ret == 0) {
+        if (v4l2_buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+            ctx->num_queued_op_buffers++;
+        } else {
+            ctx->num_queued_cp_buffers++;
+        }
+        pthread_cond_broadcast(&ctx->queue_cond);
+    }
+    pthread_mutex_unlock(&ctx->queue_lock);
+
+    return ret;
+}
+
+int
+nvv4l2_req_buffers_on_capture_plane(nvv4l2_ctx_t *ctx,
+                                    enum v4l2_buf_type buf_type,
+                                    enum v4l2_memory mem_type,
+                                    int num_buffers)
+{
+    struct v4l2_requestbuffers reqbufs;
+    int ret;
+    memset(&reqbufs, 0, sizeof(struct v4l2_requestbuffers));
+
+    reqbufs.count = num_buffers;
+    reqbufs.memory = mem_type;
+    reqbufs.type = buf_type;
+
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_REQBUFS, &reqbufs);
+    if (ret)
+        return ret;
+
+    if (reqbufs.count) {
+        ctx->cp_buffers =
+            (NvBuffer **)NVMALLOC(reqbufs.count * sizeof(NvBuffer *));
+        for (uint32_t i = 0; i < reqbufs.count; ++i) {
+            ctx->cp_buffers[i] = (NvBuffer *)NVMALLOC(sizeof(NvBuffer));
+            nvv4l2_create_bufferfmt(ctx->cp_buffers[i], buf_type, mem_type,
+                             ctx->cp_num_planes, ctx->cp_planefmts, i);
+        }
+    } else if (ctx->cp_buffers) {
+        for (uint32_t i = 0; i < ctx->cp_num_buffers; ++i) {
+            for (uint32_t j = 0; j < ctx->cp_buffers[i]->n_planes &&
+                 mem_type == V4L2_MEMORY_USERPTR; j++) {
+                NVFREE(ctx->cp_buffers[i]->planes[j].data);
+            }
+            NVFREE(ctx->cp_buffers[i]);
+        }
+        NVFREE(ctx->cp_buffers);
+        ctx->cp_buffers = NULL;
+    }
+    ctx->cp_num_buffers = reqbufs.count;
+
+    return ret;
+}
+
+int
+nvv4l2_req_buffers_on_output_plane(nvv4l2_ctx_t *ctx,
+                                   enum v4l2_buf_type buf_type,
+                                   enum v4l2_memory mem_type,
+                                   int num_buffers)
+{
+    struct v4l2_requestbuffers reqbufs;
+    int ret;
+    memset(&reqbufs, 0, sizeof(struct v4l2_requestbuffers));
+
+    reqbufs.count = num_buffers;
+    reqbufs.memory = mem_type;
+    reqbufs.type = buf_type;
+
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_REQBUFS, &reqbufs);
+    if (ret)
+        return ret;
+
+    if (reqbufs.count) {
+        ctx->op_buffers =
+            (NvBuffer **)NVMALLOC(reqbufs.count * sizeof(NvBuffer *));
+        for (uint32_t i = 0; i < reqbufs.count; ++i) {
+            ctx->op_buffers[i] = (NvBuffer *)NVMALLOC(sizeof(NvBuffer));
+            nvv4l2_create_bufferfmt(ctx->op_buffers[i], buf_type, mem_type,
+                             ctx->op_num_planes, ctx->op_planefmts, i);
+        }
+    } else if (ctx->op_buffers) {
+        for (uint32_t i = 0; i < ctx->op_num_buffers; ++i) {
+            for (uint32_t j = 0; j < ctx->op_buffers[i]->n_planes &&
+                 mem_type == V4L2_MEMORY_USERPTR; j++) {
+                NVFREE(ctx->op_buffers[i]->planes[j].data);
+            }
+            NVFREE(ctx->op_buffers[i]);
+        }
+        NVFREE(ctx->op_buffers);
+        ctx->op_buffers = NULL;
+    }
+    ctx->op_num_buffers = reqbufs.count;
+
+    return ret;
+}
+
+int
+nvv4l2_set_ext_controls(int fd, uint32_t id,
+                        uint32_t class, uint32_t value)
+{
+    int ret;
+    struct v4l2_ext_control ctl;
+    struct v4l2_ext_controls ctrls;
+
+    memset(&ctl, 0, sizeof(struct v4l2_ext_control));
+    memset(&ctrls, 0, sizeof(struct v4l2_ext_controls));
+    ctl.id = id;
+    ctl.value = value;
+    ctrls.count = 1;
+    ctrls.controls = &ctl;
+    ctrls.ctrl_class = class;
+
+    ret = v4l2_ioctl(fd, VIDIOC_S_EXT_CTRLS, &ctrls);
+
+    return ret;
+}
+
+int
+nvv4l2_set_ext_control_qp_range(int fd, uint32_t qpmin,
+                                uint32_t qpmax)
+{
+    int ret;
+    struct v4l2_ext_control ctl;
+    struct v4l2_ext_controls ctrls;
+    v4l2_ctrl_video_qp_range qprange;
+
+    memset(&ctl, 0, sizeof(struct v4l2_ext_control));
+    memset(&ctrls, 0, sizeof(struct v4l2_ext_controls));
+
+    qprange.MinQpI = qpmin;
+    qprange.MaxQpI = qpmax;
+    qprange.MinQpP = qpmin;
+    qprange.MaxQpP = qpmax;
+    qprange.MinQpB = qpmin;
+    qprange.MaxQpB = qpmax;
+
+    ctl.id = V4L2_CID_MPEG_VIDEOENC_QP_RANGE;
+    ctl.string = (char *)&qprange;
+
+    ctrls.count = 1;
+    ctrls.controls = &ctl;
+    ctrls.ctrl_class = V4L2_CTRL_CLASS_MPEG;
+
+    ret = v4l2_ioctl(fd, VIDIOC_S_EXT_CTRLS, &ctrls);
+
+    return ret;
+}
+
+int
+nvv4l2_set_ext_control_constant_qp(int fd, uint32_t qpval)
+{
+    int ret;
+    struct v4l2_ext_control ctl[3];
+    struct v4l2_ext_controls ctrls;
+
+    memset(&ctl, 0, sizeof(ctl));
+    memset(&ctrls, 0, sizeof(ctrls));
+
+    ctl[0].id = V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE;
+    ctl[0].value = 0; // disable rate control
+
+    ctl[1].id = V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP;
+    ctl[1].value = qpval;
+
+    ctl[2].id = V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP;
+    ctl[2].value = qpval;
+
+    ctrls.count = 3;
+    ctrls.controls = &ctl[0];
+    ctrls.ctrl_class = V4L2_CTRL_CLASS_MPEG;
+
+    ret = v4l2_ioctl(fd, VIDIOC_S_EXT_CTRLS, &ctrls);
+
+    return ret;
+}
+
+int
+nvv4l2_get_ext_control_metadata(int fd, uint32_t buffer_index,
+                    v4l2_ctrl_videoenc_outputbuf_metadata *enc_metadata)
+{
+    int ret;
+    struct v4l2_ext_control ctl;
+    struct v4l2_ext_controls ctrls;
+    v4l2_ctrl_video_metadata metadata;
+
+    memset(&ctl, 0, sizeof(struct v4l2_ext_control));
+    memset(&ctrls, 0, sizeof(struct v4l2_ext_controls));
+
+    metadata.buffer_index = buffer_index;
+    metadata.VideoEncMetadata =
+        (v4l2_ctrl_videoenc_outputbuf_metadata *)&enc_metadata;
+
+    ctl.id = V4L2_CID_MPEG_VIDEOENC_METADATA;
+    ctl.string = (char *)&metadata;
+
+    ctrls.count = 1;
+    ctrls.controls = &ctl;
+    ctrls.ctrl_class = V4L2_CTRL_CLASS_MPEG;
+
+    ret = v4l2_ioctl(fd, VIDIOC_S_EXT_CTRLS, &ctrls);
+
+    return ret;
+}
+
+int
+nvv4l2_set_stream_control_framerate(int fd,  uint32_t buf_type,
+                                    uint32_t framerate_num,
+                                    uint32_t framerate_den)
+{
+    int ret;
+    struct v4l2_streamparm parms;
+
+    memset(&parms, 0, sizeof(parms));
+
+    parms.parm.output.timeperframe.numerator = framerate_den;
+    parms.parm.output.timeperframe.denominator = framerate_num;
+    parms.type = buf_type;
+
+    ret = v4l2_ioctl(fd, VIDIOC_S_PARM, &parms);
+
+    return ret;
+}
+
+int
+nvv4l2_subscribe_event(int fd, uint32_t type, uint32_t id,
+                       uint32_t flags)
+{
+    struct v4l2_event_subscription sub;
+    int ret;
+
+    memset(&sub, 0, sizeof(struct v4l2_event_subscription));
+
+    sub.type = type;
+    sub.id = id;
+    sub.flags = flags;
+
+    ret = v4l2_ioctl(fd, VIDIOC_SUBSCRIBE_EVENT, &sub);
+
+    return ret;
+}
+
+void
+nvv4l2_dbg_plane_supported_formats(nvv4l2_ctx_t *ctx,
+                                   uint32_t buf_type)
+{
+    struct v4l2_fmtdesc fdesc;
+    char fourcc[5] = {0};
+    int ret;
+
+    memset(&fdesc, 0, sizeof(fdesc));
+    fdesc.type = buf_type;
+
+    av_log(ctx->avctx, AV_LOG_INFO,
+           "%s plane format support:\n",
+           buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE ?
+                                    "Output" : "Capture");
+
+    while (true) {
+        ret = v4l2_ioctl(ctx->fd, VIDIOC_ENUM_FMT, &fdesc);
+        if (ret)
+            break;
+
+        memcpy(fourcc, &fdesc.pixelformat, 4);
+        av_log(ctx->avctx, AV_LOG_INFO, "%d: %s (%s)\n",
+               fdesc.index, fourcc, fdesc.description);
+        fdesc.index++;
+    }
+}
+
+/*! TODO: Add 34.1.x support; YUV444 enum value changed. */
+NvBufferPixFmtVersion
+nvv4l2_get_pixfmt_list_version(nvv4l2_ctx_t *ctx)
+{
+    NvBufferParams params;
+    NvBufferCreateParams iParams;
+    NvBufferPixFmtVersion version;
+    int dma_fd = -1;
+    int ret;
+
+    memset(&params, 0, sizeof(params));
+    memset(&iParams, 0, sizeof(NvBufferCreateParams));
+
+    iParams.width = 1280;
+    iParams.height = 720;
+    iParams.layout = NvBufferLayout_BlockLinear;
+    iParams.payloadType = NvBufferPayload_SurfArray;
+    iParams.nvbuf_tag = NvBufferTag_NONE;
+    iParams.colorFormat = NvBufferColorFormat_NV12;
+
+    /* Create assumed NV12 buffer */
+    ret = NvBufferCreateEx(&dma_fd, &iParams);
+    if (ret || dma_fd == -1) {
+        av_log(ctx->avctx, AV_LOG_ERROR,
+               "Error getting NvBuffer Pixel Format list version!\n");
+        return NvBufferPixFmtVersion_New; /* Fallback to new */
+    }
+
+    /* Query created buffer parameters */
+    ret = NvBufferGetParams(dma_fd, &params);
+    if (ret) {
+        av_log(ctx->avctx, AV_LOG_ERROR,
+               "Error getting NvBuffer Pixel Format list version!\n");
+        return NvBufferPixFmtVersion_New; /* Fallback to new */
+    }
+
+    /* Check if returned parameters match NV12 in old BSP. */
+    if (params.num_planes == 2 && params.pitch[1] == iParams.width) {
+        av_log(ctx->avctx, AV_LOG_VERBOSE, "Old NvBuffer Utils version\n");
+        version = NvBufferPixFmtVersion_Legacy;
+    } else {
+        av_log(ctx->avctx, AV_LOG_VERBOSE, "New NvBuffer Utils version\n");
+        version = NvBufferPixFmtVersion_New;
+    }
+
+    NvBufferDestroy(dma_fd);
+
+    return version;
+}
diff --git a/libavcodec/nvv4l2.h b/libavcodec/nvv4l2.h
new file mode 100644
index 0000000000..11353bf63f
--- /dev/null
+++ b/libavcodec/nvv4l2.h
@@ -0,0 +1,339 @@
+/*
+ * Copyright (c) 2021-2022, CTCaer <ctcaer@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * Specifies the decoder device node.
+ */
+#ifndef __NVV4L2_H__
+#define __NVV4L2_H__
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <libv4l2.h>
+#include <linux/videodev2.h>
+#include "avcodec.h"
+
+#include "nvv4l2_ext_utils.h"
+
+#define NV_MAX_BUFFERS 32
+#define NV_MAX_PLANES 3
+
+/* Max timestamp accepted by NVV4L2 */
+#define NV_V4L2_TIMESTAMP_MAX_SEC ((int64_t)UINT64_C(0x1AD7F29ABCA))
+
+/* Custom values/flags to pass over info into capture plane */
+#define NV_V4L2_NOPTS_VALUE NV_V4L2_TIMESTAMP_MAX_SEC
+#define NV_V4L2_REORDERED_OPAQUE_FLAG ((int64_t)UINT64_C(0x10000000000))
+
+#define NVMIN(a,b) (((a) < (b)) ? (a) : (b))
+#define NVMAX(a, b) ((a) > (b) ? (a) : (b))
+
+/* Use app malloc/free implementation */
+#define NVMALLOC(size) (av_malloc((size)))
+#define NVCALLOC(num, size) (av_mallocz((num) * (size)))
+#define NVFREE(ptr) (av_free((ptr)))
+
+#define NVALIGN(x, a) (((x) + (a) - 1) & ~((a) - 1))
+
+typedef struct _queue {
+    uint32_t capacity;
+    uint32_t front;
+    uint32_t back;
+} NvQueues;
+
+typedef enum {
+    NV_PIX_NV12,
+    NV_PIX_YUV420
+} NvPixFormat;
+
+typedef struct _NVPACKET {
+    uint32_t flags;
+    uint32_t payload_size;
+    uint8_t *payload;
+    uint32_t width;
+    uint32_t height;
+    int64_t  pts;
+    int64_t  user_pts;
+} NvPacket;
+
+typedef struct _NVFRAME {
+    uint32_t flags;
+    uint32_t payload_size[3];
+    uint8_t *payload[3];
+    uint32_t width;
+    uint32_t height;
+    int64_t  pts;
+    int64_t  user_pts;
+} NvFrame;
+
+typedef enum {
+    NvVideoCodec_H264,              /**< H.264 */
+    NvVideoCodec_MPEG4,             /**< MPEG-4 */
+    NvVideoCodec_MPEG2,             /**< MPEG-2 */
+    NvVideoCodec_VP8,               /**< VP8 */
+    NvVideoCodec_VP9,               /**< VP9 */
+    NvVideoCodec_HEVC,              /**< H.265/HEVC */
+    NvVideoCodec_UNDEFINED,
+} NvCodingType;
+
+typedef struct {
+    uint32_t width;                 /**< Holds the width of the plane in pixels. */
+    uint32_t height;                /**< Holds the height of the plane in pixels. */
+
+    uint32_t bytesperpixel;         /**< Holds the bytes used to represent one
+                                         pixel in the plane. */
+    uint32_t stride;                /**< Holds the stride of the plane in bytes. */
+    uint32_t sizeimage;             /**< Holds the size of the plane in bytes. */
+} NvBufferPlaneFormat;
+
+    /**
+     * Holds the buffer plane parameters.
+     */
+
+typedef struct {
+    NvBufferPlaneFormat fmt;        /**< Holds the format of the plane. */
+    uint8_t *data;                  /**< Holds a pointer to the plane memory. */
+    uint32_t bytesused;             /**< Holds the number of valid bytes in the plane. */
+    int fd;                         /**< Holds the file descriptor (FD) of the plane of the
+                                     exported buffer, in the case of V4L2 MMAP buffers. */
+    uint32_t mem_offset;            /**< Holds the offset of the first valid byte
+                                         from the data pointer. */
+    uint32_t length;                /**< Holds the size of the buffer in bytes. */
+} NvBufferPlane;
+
+typedef struct {
+    enum v4l2_buf_type buf_type;    /**< Type of the buffer. */
+    enum v4l2_memory memory_type;   /**< Type of memory associated with the buffer. */
+    uint32_t index;                 /**< Holds the buffer index. */
+    uint32_t n_planes;              /**< Holds the number of planes in the buffer. */
+    NvBufferPlane planes[NV_MAX_PLANES];
+    bool mapped;
+} NvBuffer;
+
+typedef struct {
+    uint32_t width;
+    uint32_t height;
+    bool low_latency;
+    uint32_t profile;
+    uint32_t bitrate;
+    uint32_t level;
+    uint32_t tier;
+    uint32_t preset_type;
+    uint32_t lossless;
+    uint32_t twopass;
+    uint32_t iframe_interval;
+    uint32_t idr_interval;
+    uint32_t fps_n;
+    uint32_t fps_d;
+    int qmin;
+    int qmax;
+    int num_b_frames;
+    uint32_t num_ref;
+    bool sps_pps_at_idr;
+    uint32_t ratecontrol;
+} NvEncoder;
+
+/**
+ * @brief Struct defining the decoder context.
+ * The video decoder device node is `/dev/nvhost-nvdec`. The category name
+ * for the decoder is \c "NVDEC".
+ *
+ * The context stores the information for decoding.
+ * Refer to [V4L2 Video Decoder](group__V4L2Dec.html) for more information on the decoder.
+ */
+
+typedef struct {
+    uint32_t codec_width;
+    uint32_t codec_height;
+
+    NvBufferSession buf_session;
+    NvBufferPixFmtVersion pixfmt_list_ver;
+
+    uint32_t op_pixfmt;
+    uint32_t cp_pixfmt;
+    enum v4l2_memory op_mem_type;
+    enum v4l2_memory cp_mem_type;
+    enum v4l2_buf_type op_buf_type;
+    enum v4l2_buf_type cp_buf_type;
+    NvBufferPlaneFormat op_planefmts[NV_MAX_PLANES];
+    NvBufferPlaneFormat cp_planefmts[NV_MAX_PLANES];
+    uint32_t cp_num_planes;
+    uint32_t op_num_planes;
+    uint32_t cp_num_buffers;
+    uint32_t op_num_buffers;
+    NvQueues *export_pool;
+    NvBuffer **op_buffers;
+    NvBuffer **cp_buffers;
+    uint32_t num_active_op_buffers;
+    uint32_t num_queued_op_buffers;
+    uint32_t num_queued_cp_buffers;
+
+    pthread_mutex_t queue_lock;
+    pthread_cond_t queue_cond;
+    pthread_mutex_t frame_lock;
+    pthread_cond_t frame_cond;
+    pthread_t capture_thread;
+
+    bool in_error;
+    bool eos;
+    bool op_streamon;
+    bool cp_streamon;
+    bool draining_event;
+    bool low_latency;
+
+    int fd;
+    int out_dma_fd;
+    int dmabuff_fd[NV_MAX_BUFFERS];
+
+    int      plane_dma_fd[NV_MAX_BUFFERS];
+    uint32_t plane_width[MAX_NUM_PLANES];
+    uint32_t plane_height[MAX_NUM_PLANES];
+    uint32_t plane_width_aligned;
+    int64_t  frame_pts[NV_MAX_BUFFERS];
+    int64_t  frame_user_pts[NV_MAX_BUFFERS];
+
+    uint8_t *packet[NV_MAX_BUFFERS];
+    uint32_t packet_buf_size[NV_MAX_BUFFERS];
+    uint32_t packet_size[NV_MAX_BUFFERS];
+    bool packet_keyflag[NV_MAX_BUFFERS];
+
+    NvEncoder *enc;
+    AVCodecContext *avctx;
+} nvv4l2_ctx_t;
+
+/* NVV4L2 common functions */
+uint32_t nvv4l2_map_nvcodec_type(NvCodingType nv_codec_type);
+int
+nvv4l2_pool_idx_next(nvv4l2_ctx_t *ctx, NvQueues *q);
+void
+nvv4l2_pool_push(nvv4l2_ctx_t *ctx, NvQueues *q);
+int
+nvv4l2_pool_pop(nvv4l2_ctx_t *ctx, NvQueues *q);
+int
+nvv4l2_create_bufferfmt(NvBuffer *buffer, enum v4l2_buf_type buf_type,
+                     enum v4l2_memory memory_type, uint32_t n_planes,
+                     NvBufferPlaneFormat *fmt, uint32_t index);
+int
+nvv4l2_map_out(nvv4l2_ctx_t *ctx, struct v4l2_buffer *v4l2_buf,
+               enum v4l2_buf_type buf_type, enum v4l2_memory mem_type,
+               int dma_fd);
+int
+nvv4l2_unmap_out(nvv4l2_ctx_t *ctx, int index, enum v4l2_buf_type buf_type,
+                 enum v4l2_memory mem_type, int dma_fd);
+void
+nvv4l2_destroyBuffer(nvv4l2_ctx_t *ctx, NvBuffer *buffer);
+int
+nvv4l2_allocate_memory(nvv4l2_ctx_t *ctx, NvBuffer *buffer);
+int
+nvv4l2_map(nvv4l2_ctx_t *ctx, NvBuffer *buffer);
+void
+nvv4l2_unmap(nvv4l2_ctx_t *ctx, NvBuffer *buffer);
+int
+nvv4l2_query_buffer(nvv4l2_ctx_t *ctx, enum v4l2_buf_type buf_type,
+                    enum v4l2_memory memory_type, uint32_t num_planes,
+                    uint32_t index);
+int
+nvv4l2_export_buffer(nvv4l2_ctx_t *ctx, enum v4l2_buf_type buf_type,
+                     uint32_t num_planes, uint32_t index);
+int
+nvv4l2_fill_buffer_plane_format(nvv4l2_ctx_t *ctx,
+                                uint32_t *num_planes,
+                                NvBufferPlaneFormat *planefmts,
+                                uint32_t width, uint32_t height,
+                                uint32_t pixfmt);
+int
+nvv4l2_dq_event(nvv4l2_ctx_t *ctx, struct v4l2_event *event,
+                uint32_t max_wait_ms);
+int
+nvv4l2_dq_buffer(nvv4l2_ctx_t *ctx, struct v4l2_buffer *v4l2_buf,
+                 NvBuffer **buffer, enum v4l2_buf_type buf_type,
+                 enum v4l2_memory memory_type, uint32_t num_retries);
+int
+nvv4l2_q_buffer(nvv4l2_ctx_t *ctx, struct v4l2_buffer *v4l2_buf,
+                NvBuffer *buffer, enum v4l2_buf_type buf_type,
+                enum v4l2_memory memory_type, int num_planes);
+int
+nvv4l2_req_buffers_on_capture_plane(nvv4l2_ctx_t *ctx,
+                                    enum v4l2_buf_type buf_type,
+                                    enum v4l2_memory mem_type,
+                                    int num_buffers);
+int
+nvv4l2_req_buffers_on_output_plane(nvv4l2_ctx_t *ctx,
+                                   enum v4l2_buf_type buf_type,
+                                   enum v4l2_memory mem_type,
+                                   int num_buffers);
+int
+nvv4l2_set_ext_controls(int fd, uint32_t id,
+                        uint32_t class, uint32_t value);
+int
+nvv4l2_set_ext_control_qp_range(int fd, uint32_t qpmin,
+                                uint32_t qpmax);
+int
+nvv4l2_set_ext_control_constant_qp(int fd, uint32_t qpval);
+int
+nvv4l2_get_ext_control_metadata(int fd, uint32_t buffer_index,
+                    v4l2_ctrl_videoenc_outputbuf_metadata *enc_metadata);
+int
+nvv4l2_set_stream_control_framerate(int fd,  uint32_t buf_type,
+                                    uint32_t framerate_num,
+                                    uint32_t framerate_den);
+int
+nvv4l2_subscribe_event(int fd, uint32_t type, uint32_t id,
+                       uint32_t flags);
+
+NvBufferPixFmtVersion
+nvv4l2_get_pixfmt_list_version(nvv4l2_ctx_t *ctx);
+
+/* NVV4L2 debug functions */
+void
+nvv4l2_dbg_plane_supported_formats(nvv4l2_ctx_t *ctx,
+                                   uint32_t buf_type);
+
+/* NVV4L2 decoder functions */
+nvv4l2_ctx_t *nvv4l2_create_decoder(AVCodecContext *avctx,
+                                    NvCodingType nv_codec_type,
+                                    int pix_fmt);
+int
+nvv4l2_decoder_put_packet(AVCodecContext *avctx, nvv4l2_ctx_t *ctx,
+                          NvPacket *packet);
+int
+nvv4l2_decoder_get_frame(AVCodecContext *avctx, nvv4l2_ctx_t *ctx,
+                         int *buf_index, NvFrame *frame);
+int nvv4l2_decoder_close(AVCodecContext *avctx, nvv4l2_ctx_t *ctx);
+
+/* NVV4L2 encoder functions */
+nvv4l2_ctx_t *nvv4l2_create_encoder(AVCodecContext *avctx,
+                                    NvEncoder *enc,
+                                    NvCodingType codingType,
+                                    int pix_fmt);
+int
+nvv4l2_encoder_put_frame(AVCodecContext *avctx, nvv4l2_ctx_t *ctx,
+                         NvFrame *frame);
+int
+nvv4l2_encoder_get_packet(AVCodecContext *avctx,
+                          nvv4l2_ctx_t *ctx,
+                          NvPacket *packet);
+int
+nvv4l2_encoder_close(AVCodecContext *avctx, nvv4l2_ctx_t *ctx);
+
+#endif
diff --git a/libavcodec/nvv4l2_dec.c b/libavcodec/nvv4l2_dec.c
new file mode 100644
index 0000000000..b2ac349201
--- /dev/null
+++ b/libavcodec/nvv4l2_dec.c
@@ -0,0 +1,1288 @@
+/*
+ * Copyright (c) 2021-2023, CTCaer <ctcaer@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdatomic.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include "internal.h"
+#include "decode.h"
+#include "thread.h"
+#include "libavutil/log.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/opt.h"
+
+#include "nvv4l2.h"
+
+extern AVCodec ff_h264_decoder;
+extern AVCodec ff_hevc_decoder;
+extern AVCodec ff_vp9_decoder;
+
+/*
+ ** Output plane format support:
+ **  S264 (H264  Encoded Slice bitstream)
+ **  VP8F (VP8   Encoded Slice bitstream)
+ **  H264 (H264  Encoded bitstream)
+ **  H265 (H265  Encoded bitstream)
+ **  VP80 (VP8   Encoded bitstream)
+ **  VP90 (VP9   Encoded bitstream)
+ **  MPG2 (MPEG2 Encoded bitstream)
+ **  MPG4 (MPEG4 Encoded bitstream)
+ **  JPEG (JPEG  Encoded bitstream)
+ **  MJPG (MJPEG Encoded bitstream)
+ **  DVX4 (divx  Encoded bitstream)
+ **  DVX5 (divx  Encoded bitstream)
+ **
+ ** Capture plane format support:
+ **  NM12 (YUV 4:2:0)
+ */
+
+/*
+ ** Output plane memory type support:
+ **  V4L2_MEMORY_MMAP
+ **  V4L2_MEMORY_USERPTR
+ ** Capture plane memory type support:
+ **  V4L2_MEMORY_MMAP
+ **  V4L2_MEMORY_DMABUF
+ */
+
+#define DECODER_DEV "/dev/nvhost-nvdec"
+#define OP_PLANE_REQ_SIZEIMAGE 4000000
+
+typedef struct {
+    char eos_reached;
+    nvv4l2_ctx_t *ctx;
+    AVClass *av_class;
+} nvv4l2DecodeContext;
+
+static int
+set_output_plane_format(nvv4l2_ctx_t *ctx, uint32_t pixfmt,
+                        uint32_t sizeimage)
+{
+    int ret;
+    struct v4l2_format format;
+
+    memset(&format, 0, sizeof(struct v4l2_format));
+    format.type = ctx->op_buf_type;
+    format.fmt.pix_mp.pixelformat = pixfmt;
+    format.fmt.pix_mp.num_planes = 1;
+    format.fmt.pix_mp.plane_fmt[0].sizeimage = sizeimage;
+
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_S_FMT, &format);
+
+    if (ret == 0) {
+        ctx->op_num_planes = format.fmt.pix_mp.num_planes;
+        for (uint32_t i = 0; i < ctx->op_num_planes; i++) {
+            ctx->op_planefmts[i].stride =
+                format.fmt.pix_mp.plane_fmt[i].bytesperline;
+            ctx->op_planefmts[i].sizeimage =
+                format.fmt.pix_mp.plane_fmt[i].sizeimage;
+        }
+    }
+
+    return ret;
+}
+
+static int
+set_capture_plane_format(AVCodecContext *avctx, nvv4l2_ctx_t *ctx,
+                         uint32_t pixfmt, uint32_t width, uint32_t height)
+{
+    int ret;
+    struct v4l2_format format;
+    uint32_t num_bufferplanes;
+    NvBufferPlaneFormat planefmts[NV_MAX_PLANES];
+
+    nvv4l2_fill_buffer_plane_format(ctx, &num_bufferplanes, planefmts, width,
+                             height, pixfmt);
+    ctx->cp_num_planes = num_bufferplanes;
+    for (uint32_t i = 0; i < num_bufferplanes; i++) {
+        ctx->cp_planefmts[i] = planefmts[i];
+    }
+    memset(&format, 0, sizeof(struct v4l2_format));
+    format.type = ctx->cp_buf_type;
+    format.fmt.pix_mp.width = width;
+    format.fmt.pix_mp.height = height;
+    format.fmt.pix_mp.pixelformat = pixfmt;
+    format.fmt.pix_mp.num_planes = num_bufferplanes;
+
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_S_FMT, &format);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR, "Error in VIDIOC_S_FMT!\n");
+        ctx->in_error = true;
+    } else {
+        ctx->cp_num_planes = format.fmt.pix_mp.num_planes;
+        for (uint32_t i = 0; i < ctx->cp_num_planes; i++) {
+            ctx->cp_planefmts[i].stride =
+                format.fmt.pix_mp.plane_fmt[i].bytesperline;
+            ctx->cp_planefmts[i].sizeimage =
+                format.fmt.pix_mp.plane_fmt[i].sizeimage;
+        }
+    }
+
+    return ret;
+}
+
+static void query_set_capture(AVCodecContext *avctx, nvv4l2_ctx_t *ctx)
+{
+    struct v4l2_format format;
+    struct v4l2_crop crop;
+    struct v4l2_control ctl;
+    int ret, cp_num_old_buffers;
+    int32_t min_cap_buffers;
+    NvBufferCreateParams input_params = { 0 };
+    NvBufferCreateParams cap_params = { 0 };
+
+    if (ctx->in_error || ctx->eos)
+        return;
+
+    /* Get format on capture plane set by device.
+     ** This may change after an resolution change event.
+     */
+    format.type = ctx->cp_buf_type;
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_G_FMT, &format);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Could not get format from decoder capture plane!\n");
+        ctx->in_error = true;
+        return;
+    }
+
+    /* Query cropping size and position. */
+    crop.type = ctx->cp_buf_type;
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_G_CROP, &crop);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Could not get crop from decoder capture plane!\n");
+        ctx->in_error = true;
+        return;
+    }
+
+    /* Set codec resolution */
+    ctx->codec_width = crop.c.width;
+    ctx->codec_height = crop.c.height;
+
+    av_log(avctx, AV_LOG_VERBOSE, "Resolution changed to: %dx%d\n",
+           ctx->codec_width, ctx->codec_height);
+
+    /* Destroy all allocated transform/export DMA buffers. */
+    for (uint32_t i = 0; i < NV_MAX_BUFFERS; i++) {
+        if (ctx->plane_dma_fd[i] != -1) {
+            ret = NvBufferDestroy(ctx->plane_dma_fd[i]);
+            if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR,
+                       "Failed to destroy plane buffer!\n");
+            } else {
+                ctx->plane_dma_fd[i] = -1;
+            }
+        }
+    }
+
+    /*
+     ** Due to VIC constrains the transformation from Block Linear to Pitch
+     ** must have aligned widths to 64B. Otherwise the frame might be produced
+     ** as scrambled.
+     */
+    ctx->plane_width_aligned = NVALIGN(crop.c.width, 64);
+    if (ctx->plane_width_aligned != crop.c.width)
+        av_log(avctx, AV_LOG_VERBOSE, "Linesize got aligned: %d -> %d\n",
+           crop.c.width, ctx->plane_width_aligned);
+    crop.c.width = ctx->plane_width_aligned;
+
+    /* Create transform/export DMA buffers. */
+    input_params.width = crop.c.width;
+    input_params.height = crop.c.height;
+    input_params.layout = NvBufferLayout_Pitch;
+    input_params.payloadType = NvBufferPayload_SurfArray;
+    input_params.nvbuf_tag = NvBufferTag_VIDEO_CONVERT;
+
+    switch (ctx->cp_pixfmt) {
+    case V4L2_PIX_FMT_YUV420M:
+        input_params.colorFormat = NvBufferColorFormat_YUV420;
+        break;
+    case V4L2_PIX_FMT_NV12M:
+        input_params.colorFormat = NvBufferColorFormat_NV12;
+        if (ctx->pixfmt_list_ver == NvBufferPixFmtVersion_New)
+            input_params.colorFormat++;
+        break;
+    }
+
+    for (uint32_t i = 0; i < NV_MAX_BUFFERS; i++) {
+        ret = NvBufferCreateEx(&ctx->plane_dma_fd[i], &input_params);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR, "Creation of dmabuf failed!\n");
+            ctx->in_error = true;
+        }
+    }
+
+    /* Stop streaming. */
+    pthread_mutex_lock(&ctx->queue_lock);
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_STREAMOFF, &ctx->cp_buf_type);
+    if (ret) {
+        ctx->in_error = true;
+    } else {
+        pthread_cond_broadcast(&ctx->queue_cond);
+    }
+    pthread_mutex_unlock(&ctx->queue_lock);
+
+    /* Request buffers with count 0 and destroy all
+     ** previously allocated buffers.
+     */
+    cp_num_old_buffers = ctx->cp_num_buffers;
+    ret = nvv4l2_req_buffers_on_capture_plane(ctx,
+                                              ctx->cp_buf_type,
+                                              ctx->cp_mem_type, 0);
+    if (ret) {
+        av_log(avctx, AV_LOG_WARNING,
+               "Error in requesting 0 capture plane buffers!\n");
+    }
+
+    /* Destroy previous DMA buffers. */
+    for (uint32_t i = 0; i < cp_num_old_buffers; i++) {
+        if (ctx->dmabuff_fd[i] != -1) {
+            ret = NvBufferDestroy(ctx->dmabuff_fd[i]);
+            if (ret) {
+                av_log(avctx, AV_LOG_ERROR,
+                       "Failed to Destroy NvBuffer!\n");
+                ctx->in_error = true;
+            } else {
+                ctx->dmabuff_fd[i] = -1;
+            }
+        }
+    }
+    if (ctx->in_error)
+        return;
+
+    /* Set capture plane format to update vars. */
+    ret = set_capture_plane_format(avctx, ctx,
+                                   format.fmt.pix_mp.pixelformat,
+                                   format.fmt.pix_mp.width,
+                                   format.fmt.pix_mp.height);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Error in setting capture plane format!\n");
+        ctx->in_error = true;
+        return;
+    }
+
+    /* Get control value for min buffers which have to
+     ** be requested on capture plane.
+     */
+    ctl.id = V4L2_CID_MIN_BUFFERS_FOR_CAPTURE;
+
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_G_CTRL, &ctl);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR, "Error getting value of control!\n");
+        ctx->in_error = true;
+        return;
+    } else {
+        min_cap_buffers = ctl.value;
+    }
+
+    /* Set color format based on colorspace and quantization type. */
+    switch(format.fmt.pix_mp.colorspace)
+    {
+    case V4L2_COLORSPACE_REC709:
+        if (format.fmt.pix_mp.quantization == V4L2_QUANTIZATION_DEFAULT)
+        {
+            av_log(avctx, AV_LOG_VERBOSE,
+                "Colorspace ITU-R BT.709 with standard range luma (16-235)\n");
+            cap_params.colorFormat = NvBufferColorFormat_NV12_709;
+        }
+        else
+        {
+            av_log(avctx, AV_LOG_VERBOSE,
+                "Colorspace ITU-R BT.709 with extended range luma (0-255)\n");
+            cap_params.colorFormat = NvBufferColorFormat_NV12_709_ER;
+        }
+        break;
+    case V4L2_COLORSPACE_BT2020:
+        av_log(avctx, AV_LOG_VERBOSE,
+               "Colorspace ITU-R BT.2020\n");
+        cap_params.colorFormat = NvBufferColorFormat_NV12_2020;
+        break;
+    default:
+        av_log(avctx, AV_LOG_VERBOSE,
+               "Colorspace details are missing, using default\n");
+    case V4L2_COLORSPACE_SMPTE170M:
+        if (format.fmt.pix_mp.quantization == V4L2_QUANTIZATION_DEFAULT)
+        {
+            av_log(avctx, AV_LOG_VERBOSE,
+                "Colorspace ITU-R BT.601 with standard range luma (16-235)\n");
+            cap_params.colorFormat = NvBufferColorFormat_NV12;
+        }
+        else
+        {
+            av_log(avctx, AV_LOG_VERBOSE,
+                "Colorspace ITU-R BT.601 with extended range luma (0-255)\n");
+            cap_params.colorFormat = NvBufferColorFormat_NV12_ER;
+        }
+        break;
+    }
+
+    /* Increment color format if NvBuffer is newer. */
+    if (ctx->pixfmt_list_ver == NvBufferPixFmtVersion_New)
+        cap_params.colorFormat++;
+
+    /* Request number of buffers returned by ctrl, plus 10 more. */
+    ctx->cp_num_buffers = min_cap_buffers + 10;
+
+    /* Create DMA Buffers by defining the parameters for the HW Buffer. */
+    cap_params.width = crop.c.width;
+    cap_params.height = crop.c.height;
+    cap_params.layout = NvBufferLayout_BlockLinear;
+    cap_params.payloadType = NvBufferPayload_SurfArray;
+    cap_params.nvbuf_tag = NvBufferTag_VIDEO_DEC;
+
+    for (uint32_t i = 0; i < ctx->cp_num_buffers; i++) {
+        ret = NvBufferCreateEx(&ctx->dmabuff_fd[i], &cap_params);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to create buffers!\n");
+            ctx->in_error = true;
+            return;
+        }
+    }
+
+    /* Request buffers on capture plane. */
+    ret = nvv4l2_req_buffers_on_capture_plane(ctx,
+                                              ctx->cp_buf_type,
+                                              ctx->cp_mem_type,
+                                              ctx->cp_num_buffers);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Error in requesting capture plane buffers!\n");
+        ctx->in_error = true;
+        return;
+    }
+
+    /* Set max performance mode if low latency is requested. */
+    if (ctx->low_latency) {
+        ret = nvv4l2_set_ext_controls(ctx->fd,
+                                V4L2_CID_MPEG_VIDEO_MAX_PERFORMANCE, 0, 1);
+        if (ret) {
+            av_log(avctx, AV_LOG_WARNING,
+                   "Failed to set control max performance!\n");
+        }
+    }
+
+    /* Set streaming status ON on capture plane. */
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_STREAMON, &ctx->cp_buf_type);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR, "Streaming error on capture plane!\n");
+        ctx->in_error = true;
+        return;
+    }
+
+    /* Enqueue all empty buffers on capture plane. */
+    for (uint32_t i = 0; i < ctx->cp_num_buffers; i++) {
+        struct v4l2_buffer v4l2_buf;
+        struct v4l2_plane planes[NV_MAX_PLANES];
+
+        memset(&v4l2_buf, 0, sizeof(v4l2_buf));
+        memset(planes, 0, sizeof(planes));
+
+        v4l2_buf.index = i;
+        v4l2_buf.m.planes = planes;
+        v4l2_buf.type = ctx->cp_buf_type;
+        v4l2_buf.memory = ctx->cp_mem_type;
+        v4l2_buf.length = ctx->cp_num_planes;
+        /* Set DMA plane handle. */
+        v4l2_buf.m.planes[0].m.fd = ctx->dmabuff_fd[i];
+        v4l2_buf.m.planes[1].m.fd = ctx->dmabuff_fd[i];
+
+        ret = nvv4l2_q_buffer(ctx, &v4l2_buf, ctx->cp_buffers[i],
+                              ctx->cp_buf_type, ctx->cp_mem_type,
+                              ctx->cp_num_planes);
+
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR, "Qing failed on capture plane!\n");
+            ctx->cp_streamon = true;
+            ctx->in_error = true;
+            return;
+        }
+    }
+
+    ctx->cp_streamon = true;
+
+    av_log(avctx, AV_LOG_VERBOSE, "Query and set capture successful\n");
+
+    return;
+}
+
+static void *dec_capture_thread(void *arg)
+{
+    nvv4l2_ctx_t *ctx = (nvv4l2_ctx_t *)arg;
+    struct v4l2_event event;
+    int buf_index;
+    int ret;
+
+    av_log(ctx->avctx, AV_LOG_VERBOSE, "Starting capture thread\n");
+
+    /* Need to wait for the first Resolution change event, so that
+     ** the decoder knows the stream resolution and can allocate
+     ** appropriate buffers when REQBUFS is called.
+     */
+    do {
+        /* Dequeue the subscribed event. */
+        ret = nvv4l2_dq_event(ctx, &event, 50000);
+        if (ret) {
+            if (errno == EAGAIN) {
+                av_log(ctx->avctx, AV_LOG_VERBOSE,
+                       "Timeout waiting for first resolution event!\n");
+            } else {
+                av_log(ctx->avctx, AV_LOG_ERROR,
+                       "Error in dequeuing decoder event!\n");
+            }
+            ctx->in_error = true;
+            break;
+        }
+    }
+    while ((event.type != V4L2_EVENT_RESOLUTION_CHANGE) &&
+           !ctx->in_error && !ctx->eos);
+
+    /* Received first resolution change event
+     ** Format and buffers are now set on capture.
+     */
+    query_set_capture(ctx->avctx, ctx);
+
+    /* Check for resolution event to again
+     ** set format and buffers on capture plane.
+     */
+    while (!ctx->in_error && !ctx->eos) {
+        ret = nvv4l2_dq_event(ctx, &event, 0);
+        if (ret == 0) {
+            switch (event.type) {
+            case V4L2_EVENT_RESOLUTION_CHANGE:
+                query_set_capture(ctx->avctx, ctx);
+                continue;
+            }
+        }
+
+        /* Main Capture loop for DQ and Q. */
+        while (!ctx->eos) {
+            struct v4l2_buffer v4l2_cp_buf;
+            struct v4l2_plane capture_planes[NV_MAX_PLANES];
+            NvBufferRect src_rect, dest_rect;
+            NvBufferParams buf_params;
+            NvBufferTransformParams transform_params;
+
+            memset(&v4l2_cp_buf, 0, sizeof(v4l2_cp_buf));
+            memset(capture_planes, 0, sizeof(capture_planes));
+            v4l2_cp_buf.m.planes = capture_planes;
+
+            /* Dequeue the filled buffer. */
+            if (nvv4l2_dq_buffer(ctx, &v4l2_cp_buf, NULL,
+                 ctx->cp_buf_type, ctx->cp_mem_type, 0)) {
+                if (errno == EAGAIN) {
+                    usleep(1000);
+                }
+                break;
+            }
+
+            /* Transformation parameters are defined
+             ** which are passed to the NvBufferTransform
+             ** for required conversion.
+             */
+            src_rect.top = 0;
+            src_rect.left = 0;
+            src_rect.width = ctx->codec_width;
+            src_rect.height = ctx->codec_height;
+            dest_rect.top = 0;
+            dest_rect.left = 0;
+            dest_rect.width = ctx->codec_width;
+            dest_rect.height = ctx->codec_height;
+
+            /* @transform_flag defines the flags for enabling the
+             ** valid transforms. All the valid parameters are
+             **  present in the nvv4l2_ext_utils header.
+             */
+            transform_params.transform_flag = NVBUFFER_TRANSFORM_FILTER;
+            transform_params.transform_flip = NvBufferTransform_None;
+            transform_params.transform_filter =
+                                            NvBufferTransform_Filter_Smart;
+            transform_params.src_rect = src_rect;
+            transform_params.dst_rect = dest_rect;
+            transform_params.session = ctx->buf_session;
+
+            pthread_mutex_lock(&ctx->queue_lock);
+
+            buf_index = nvv4l2_pool_idx_next(ctx, ctx->export_pool);
+
+            /* Blocklinear to Pitch transformation is required
+             ** to dump the raw decoded buffer data.
+             */
+            if (buf_index >= 0) {
+                ret = NvBufferTransform(ctx->dmabuff_fd[v4l2_cp_buf.index],
+                                        ctx->plane_dma_fd[buf_index],
+                                        &transform_params);
+                if (ret == -1) {
+                    ctx->in_error = true;
+                    av_log(ctx->avctx, AV_LOG_ERROR, "Transform failed!\n");
+                    pthread_mutex_unlock(&ctx->queue_lock);
+                    break;
+                }
+
+                ret = NvBufferGetParams(ctx->plane_dma_fd[buf_index],
+                                        &buf_params);
+                if (ret) {
+                    ctx->in_error = true;
+                    av_log(ctx->avctx, AV_LOG_ERROR, "GetParams failed!\n");
+                    pthread_mutex_unlock(&ctx->queue_lock);
+                    break;
+                }
+            }
+
+            ctx->plane_width[0] = buf_params.width[0];
+            ctx->plane_height[0] = buf_params.height[0];
+            ctx->plane_width[1] = buf_params.width[1];
+            ctx->plane_height[1] = buf_params.height[1];
+            if (ctx->cp_pixfmt == V4L2_PIX_FMT_YUV420M) {
+                ctx->plane_width[2] = buf_params.width[2];
+                ctx->plane_height[2] = buf_params.height[2];
+            }
+
+            /* Set timestamp based on origin pts flags */
+            if (buf_index >= 0) {
+                if (v4l2_cp_buf.timestamp.tv_usec == 0 &&
+                     v4l2_cp_buf.timestamp.tv_sec == NV_V4L2_NOPTS_VALUE) {
+                    /* Origin packet had no pts and user pts values. */
+                    ctx->frame_pts[buf_index] = AV_NOPTS_VALUE;
+                    ctx->frame_user_pts[buf_index] = AV_NOPTS_VALUE;
+                } else if (v4l2_cp_buf.timestamp.tv_sec &
+                           NV_V4L2_REORDERED_OPAQUE_FLAG) {
+                    /* Origin packet had only user pts value. */
+                    v4l2_cp_buf.timestamp.tv_sec &=
+                                   (~NV_V4L2_REORDERED_OPAQUE_FLAG);
+                    ctx->frame_pts[buf_index] = AV_NOPTS_VALUE;
+                    ctx->frame_user_pts[buf_index] =
+                                v4l2_cp_buf.timestamp.tv_usec +
+                                (v4l2_cp_buf.timestamp.tv_sec * AV_TIME_BASE);
+                } else {
+                    /* Origin packet had pts value. */
+                    ctx->frame_pts[buf_index] =
+                                v4l2_cp_buf.timestamp.tv_usec +
+                                (v4l2_cp_buf.timestamp.tv_sec * AV_TIME_BASE);
+                   ctx->frame_user_pts[buf_index] = AV_NOPTS_VALUE;
+                }
+            }
+
+            nvv4l2_pool_push(ctx, ctx->export_pool);
+            pthread_mutex_unlock(&ctx->queue_lock);
+
+            if (ctx->low_latency) {
+                pthread_mutex_lock(&ctx->frame_lock);
+                pthread_cond_signal(&ctx->frame_cond);
+                pthread_mutex_unlock(&ctx->frame_lock);
+            }
+
+            /* Set DMA plane handle. */
+            v4l2_cp_buf.m.planes[0].m.fd = ctx->dmabuff_fd[v4l2_cp_buf.index];
+
+            /* Queue the buffer. */
+            ret = nvv4l2_q_buffer(ctx, &v4l2_cp_buf, NULL, ctx->cp_buf_type,
+                                  ctx->cp_mem_type, ctx->cp_num_planes);
+
+            if (ret) {
+                av_log(ctx->avctx, AV_LOG_ERROR,
+                       "Qing failed on capture plane!\n");
+                if (ctx->draining_event) {
+                    ctx->draining_event = false;
+                    av_log(ctx->avctx, AV_LOG_ERROR,
+                           "Draining event, rejecting error\n");
+                } else {
+                    ctx->in_error = true;
+                }
+                break;
+            }
+        }
+    }
+
+    if (ctx->low_latency) {
+        pthread_mutex_lock(&ctx->frame_lock);
+        pthread_cond_broadcast(&ctx->frame_cond);
+        pthread_mutex_unlock(&ctx->frame_lock);
+    }
+
+    av_log(ctx->avctx, AV_LOG_VERBOSE,
+           "Exiting decoder capture loop thread\n");
+    return NULL;
+}
+
+int
+nvv4l2_decoder_get_frame(AVCodecContext *avctx, nvv4l2_ctx_t *ctx,
+                         int *buf_index, NvFrame *frame)
+{
+    struct timespec timeout;
+    struct timeval now;
+    int _buf_index;
+    int ret = 0;
+
+    /* In low latency mode, block until a decoded frame is ready. */
+    if (ctx->low_latency) {
+        pthread_mutex_lock(&ctx->frame_lock);
+        while (atomic_load(&ctx->export_pool->capacity) == 0 &&
+               !ctx->eos && !ctx->in_error && ret != ETIMEDOUT) {
+            /* 500ms timeout */
+            gettimeofday(&now, NULL);
+            timeout.tv_nsec = (now.tv_usec + 500000L) * 1000L;
+            timeout.tv_sec = now.tv_sec + timeout.tv_nsec / 1000000000L;
+            timeout.tv_nsec = timeout.tv_nsec % 1000000000L;
+
+            ret = pthread_cond_timedwait(&ctx->frame_cond,
+                                         &ctx->frame_lock, &timeout);
+        }
+        pthread_mutex_unlock(&ctx->frame_lock);
+    }
+
+    if (ctx->export_pool->capacity == 0)
+        return 1;
+
+    _buf_index = nvv4l2_pool_pop(ctx, ctx->export_pool);
+
+    frame->width = ctx->codec_width;
+    frame->height = ctx->codec_height;
+    frame->pts = ctx->frame_pts[_buf_index];
+    frame->user_pts = ctx->frame_user_pts[_buf_index];
+
+    *buf_index = _buf_index;
+
+    return 0;
+
+}
+
+int
+nvv4l2_decoder_put_packet(AVCodecContext *avctx, nvv4l2_ctx_t *ctx,
+                          NvPacket *packet)
+{
+    int ret;
+    /* Read the encoded data and Enqueue the output
+     ** plane buffers. Exit loop in case file read is complete.
+     */
+    struct v4l2_buffer v4l2_buf_op;
+    struct v4l2_plane queue_op_planes[NV_MAX_PLANES];
+    NvBuffer *buffer;
+    memset(&v4l2_buf_op, 0, sizeof(v4l2_buf_op));
+    memset(queue_op_planes, 0, sizeof(queue_op_planes));
+    v4l2_buf_op.m.planes = queue_op_planes;
+
+    if (ctx->num_active_op_buffers < ctx->op_num_buffers) {
+        /* Get an unused buffer to add to the queue. */
+        buffer = ctx->op_buffers[ctx->num_active_op_buffers];
+        v4l2_buf_op.index = ctx->num_active_op_buffers;
+    } else {
+        /* Dequeue a finished buffer and reuse it. */
+        ret = nvv4l2_dq_buffer(ctx, &v4l2_buf_op, &buffer,
+                               ctx->op_buf_type, ctx->op_mem_type, -1);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Error DQing buffer at output plane!\n");
+            ctx->in_error = true;
+            return -1;
+        }
+    }
+
+    /* Copy packet data. */
+    memcpy(buffer->planes[0].data, packet->payload, packet->payload_size);
+    buffer->planes[0].bytesused = packet->payload_size;
+
+    v4l2_buf_op.m.planes[0].bytesused = buffer->planes[0].bytesused;
+
+    /* Set timestamp based on packet flags. */
+    v4l2_buf_op.flags |= V4L2_BUF_FLAG_TIMESTAMP_COPY;
+    if (packet->pts != AV_NOPTS_VALUE) {
+        /* Packet pts is valid */
+        v4l2_buf_op.timestamp.tv_sec = packet->pts / AV_TIME_BASE;
+        v4l2_buf_op.timestamp.tv_usec = packet->pts % AV_TIME_BASE;
+    } else if (packet->user_pts != AV_NOPTS_VALUE) {
+        /* User pts is valid */
+        v4l2_buf_op.timestamp.tv_sec = packet->user_pts / AV_TIME_BASE;
+        v4l2_buf_op.timestamp.tv_usec = packet->user_pts % AV_TIME_BASE;
+        v4l2_buf_op.timestamp.tv_sec |= NV_V4L2_REORDERED_OPAQUE_FLAG;
+    } else {
+        /* No valid pts or user pts */
+        v4l2_buf_op.timestamp.tv_sec = NV_V4L2_NOPTS_VALUE;
+        v4l2_buf_op.timestamp.tv_usec = 0;
+    }
+
+    /* Queue packet on output plane. */
+    ret = nvv4l2_q_buffer(ctx, &v4l2_buf_op, buffer,
+                   ctx->op_buf_type, ctx->op_mem_type, ctx->op_num_planes);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR, "Error Qing buffer at output plane!\n");
+        ctx->in_error = true;
+        return -1;
+    }
+
+    if (ctx->num_active_op_buffers < ctx->op_num_buffers) {
+        ctx->num_active_op_buffers++;
+    }
+
+    if (v4l2_buf_op.m.planes[0].bytesused == 0) {
+        ctx->eos = true;
+        av_log(avctx, AV_LOG_VERBOSE, "Input file read complete\n");
+    }
+
+    return 0;
+}
+
+nvv4l2_ctx_t *nvv4l2_create_decoder(AVCodecContext *avctx,
+                                    NvCodingType nv_codec_type,
+                                    int pix_fmt)
+{
+    nvv4l2_ctx_t *ctx = (nvv4l2_ctx_t *)NVCALLOC(1, sizeof(nvv4l2_ctx_t));
+    int ret = 0;
+    int flags = 0;
+    ctx->avctx = avctx;
+
+    /* The call creates a new V4L2 Video Decoder object
+     ** on the device node "/dev/nvhost-nvdec"
+     ** Additional flags can also be given with which the device
+     ** should be opened.
+     ** This opens the device in Blocking mode.
+     */
+    ctx->fd = v4l2_open(DECODER_DEV, flags | O_RDWR);
+    if (ctx->fd == -1) {
+        av_log(avctx, AV_LOG_ERROR, "Could not open device!\n");
+        ctx->in_error = true;
+        return ctx;
+    }
+
+    /* Initialization. */
+    ctx->cp_pixfmt = pix_fmt;
+    ctx->op_pixfmt = nvv4l2_map_nvcodec_type(nv_codec_type);
+
+    /* Get NvBuffer pixel format list version */
+    ctx->pixfmt_list_ver = nvv4l2_get_pixfmt_list_version(ctx);
+
+    /* Get a NvBuffer session for interprocess transforms */
+    ctx->buf_session = NvBufferSessionCreate();
+
+    /* Decoder code assumes that the following do not change.
+     ** If another memory type is wanted, relevant changes should be done
+     ** to the rest of the code.
+     */
+    ctx->op_mem_type = V4L2_MEMORY_USERPTR;
+    ctx->cp_mem_type = V4L2_MEMORY_DMABUF;
+
+    ctx->op_buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+    ctx->cp_buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+
+    for (uint32_t i = 0; i < NV_MAX_BUFFERS; i++) {
+        ctx->dmabuff_fd[i] = -1;
+        ctx->plane_dma_fd[i] = -1;
+    }
+
+    /* Allocate packet pool. */
+    ctx->export_pool = (NvQueues *)NVCALLOC(1, sizeof(NvQueues));
+
+    /* Initialize mutexes */
+    pthread_mutex_init(&ctx->queue_lock, NULL);
+    pthread_mutex_init(&ctx->frame_lock, NULL);
+    pthread_cond_init(&ctx->queue_cond, NULL);
+    pthread_cond_init(&ctx->frame_cond, NULL);
+
+    /* Subscribe to Resolution change event.
+     ** This is required to catch whenever resolution change event
+     ** is triggered to set the format on capture plane.
+     */
+    ret = nvv4l2_subscribe_event(ctx->fd,
+                                 V4L2_EVENT_RESOLUTION_CHANGE,
+                                 0, 0);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Failed to subscribe for resolution change!\n");
+        ctx->in_error = true;
+    }
+
+    /* Set format on output plane.
+     ** The format of the encoded bitstream is set.
+     */
+    ret = set_output_plane_format(ctx, ctx->op_pixfmt, OP_PLANE_REQ_SIZEIMAGE);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Error in setting output plane format!\n");
+        ctx->in_error = true;
+    }
+
+    /* Set appropriate controls.
+     ** V4L2_CID_MPEG_VIDEO_DISABLE_COMPLETE_FRAME_INPUT control is
+     ** set to false as the application always sends NALUs.
+     ** Also, mandatory when V4L2_BUF_FLAG_TIMESTAMP_COPY is used.
+     */
+    ret =
+        nvv4l2_set_ext_controls(ctx->fd,
+                         V4L2_CID_MPEG_VIDEO_DISABLE_COMPLETE_FRAME_INPUT,
+                         0, 0);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Failed to set control enable complete frame!\n");
+        ctx->in_error = true;
+    }
+
+    /* Request buffers on output plane to fill
+     ** the input bitstream.
+     */
+    ret = nvv4l2_req_buffers_on_output_plane(ctx,
+                                             ctx->op_buf_type,
+                                             ctx->op_mem_type, 10);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Error in requesting buffers on output plane!\n");
+        ctx->in_error = true;
+    }
+
+    for (uint32_t i = 0; i < ctx->op_num_buffers; i++) {
+        if (nvv4l2_allocate_memory(ctx, ctx->op_buffers[i])) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Buffer mapping error on output plane!\n");
+            ctx->in_error = true;
+        }
+    }
+
+    /* Start stream processing on output plane
+     ** by setting the streaming status ON.
+     */
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_STREAMON, &ctx->op_buf_type);
+    if (ret != 0) {
+        av_log(avctx, AV_LOG_ERROR, "Streaming error on output plane!\n");
+        ctx->in_error = true;
+    }
+
+    ctx->op_streamon = true;
+
+    /* Create and start capture loop thread. */
+    pthread_create(&ctx->capture_thread, NULL, dec_capture_thread, ctx);
+
+    return ctx;
+}
+
+int nvv4l2_decoder_close(AVCodecContext *avctx, nvv4l2_ctx_t *ctx)
+{
+    int ret, cp_num_old_buffers;
+
+    if (!ctx)
+        return 0;
+
+    pthread_mutex_lock(&ctx->queue_lock);
+    ctx->eos = true;
+    pthread_mutex_unlock(&ctx->queue_lock);
+    if (ctx->fd != -1) {
+        /* Stop streaming on both planes. */
+        ret = v4l2_ioctl(ctx->fd, VIDIOC_STREAMOFF, &ctx->op_buf_type);
+        ret = v4l2_ioctl(ctx->fd, VIDIOC_STREAMOFF, &ctx->cp_buf_type);
+        ctx->op_streamon = false;
+        ctx->cp_streamon = false;
+
+        /* Wait for capture thread to exit. */
+        if (ctx->capture_thread) {
+            pthread_join(ctx->capture_thread, NULL);
+        }
+
+        /* Request 0 buffers on both planes. */
+        nvv4l2_req_buffers_on_output_plane(ctx,
+                                           ctx->op_buf_type,
+                                           ctx->op_mem_type, 0);
+
+        cp_num_old_buffers = ctx->cp_num_buffers;
+        nvv4l2_req_buffers_on_capture_plane(ctx,
+                                            ctx->cp_buf_type,
+                                            ctx->cp_mem_type, 0);
+
+        /* All allocated DMA buffers must be destroyed. */
+        for (uint32_t i = 0; i < cp_num_old_buffers; i++) {
+            if (ctx->dmabuff_fd[i] != -1) {
+                ret = NvBufferDestroy(ctx->dmabuff_fd[i]);
+                if (ret < 0) {
+                    av_log(avctx, AV_LOG_ERROR,
+                           "Failed to destroy dma buffer!\n");
+                }
+                ctx->dmabuff_fd[i] = -1;
+            }
+        }
+
+        /* Destroy all allocated transform/export DMA buffers. */
+        for (uint32_t i = 0; i < NV_MAX_BUFFERS; i++) {
+            if (ctx->plane_dma_fd[i] != -1) {
+                ret = NvBufferDestroy(ctx->plane_dma_fd[i]);
+                if (ret < 0) {
+                    av_log(avctx, AV_LOG_ERROR,
+                           "Failed to destroy plane buffer!\n");
+                }
+                ctx->plane_dma_fd[i] = -1;
+            }
+        }
+
+        /* Destroy NvBuffer session. */
+        if (ctx->buf_session)
+            NvBufferSessionDestroy(ctx->buf_session);
+
+        NVFREE(ctx->export_pool);
+
+        /* Close the opened V4L2 device. */
+        ret = v4l2_close(ctx->fd);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR, "Unable to close the device!\n");
+        }
+
+        /* Free mutexes */
+        pthread_mutex_destroy(&ctx->queue_lock);
+        pthread_mutex_destroy(&ctx->frame_lock);
+        pthread_cond_destroy(&ctx->queue_cond);
+        pthread_cond_destroy(&ctx->frame_cond);
+    }
+
+    /* Report application run status on exit. */
+    if (ctx->in_error) {
+        av_log(avctx, AV_LOG_VERBOSE, "Decoder Run failed\n");
+    } else {
+        av_log(avctx, AV_LOG_VERBOSE, "Decoder Run was successful\n");
+    }
+
+    NVFREE(ctx);
+
+    return ret;
+}
+
+static NvCodingType map_avcodec_id(enum AVCodecID id)
+{
+    switch (id) {
+    case AV_CODEC_ID_H264:
+        return NvVideoCodec_H264;
+    case AV_CODEC_ID_HEVC:
+        return NvVideoCodec_HEVC;
+    case AV_CODEC_ID_MPEG2VIDEO:
+        return NvVideoCodec_MPEG2;
+    case AV_CODEC_ID_MPEG4:
+        return NvVideoCodec_MPEG4;
+    case AV_CODEC_ID_VP8:
+        return NvVideoCodec_VP8;
+    case AV_CODEC_ID_VP9:
+        return NvVideoCodec_VP9;
+    }
+    return NvVideoCodec_UNDEFINED;
+}
+
+static int nvv4l2dec_codec_fallback(AVCodecContext *avctx)
+{
+    av_log(avctx, AV_LOG_WARNING, "Falling back to software decoding.\n");
+
+    switch (avctx->codec_id) {
+    case AV_CODEC_ID_H264:
+        avctx->codec = &ff_h264_decoder;
+        break;
+    case AV_CODEC_ID_HEVC:
+        avctx->codec = &ff_hevc_decoder;
+        break;
+    case AV_CODEC_ID_VP9:
+        avctx->codec = &ff_vp9_decoder;
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "Unsupported codec fallback!\n");
+        return AVERROR_BUG;
+    }
+
+    av_opt_free(avctx->priv_data);
+
+    if (avctx->codec->priv_data_size > 0) {
+        avctx->priv_data = av_mallocz(avctx->codec->priv_data_size);
+        if (!avctx->priv_data)
+            return AVERROR(ENOMEM);
+    }
+
+    if (HAVE_THREADS
+        && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {
+        ff_thread_init(avctx);
+    }
+    if (!HAVE_THREADS && !(avctx->codec->caps_internal & FF_CODEC_CAP_AUTO_THREADS))
+        avctx->thread_count = 1;
+
+    if (avctx->codec->priv_class) {
+        *(const AVClass **)avctx->priv_data = avctx->codec->priv_class;
+        av_opt_set_defaults(avctx->priv_data);
+    }
+
+    return avctx->codec->init(avctx);
+}
+
+static int nvv4l2dec_init(AVCodecContext *avctx)
+{
+    nvv4l2DecodeContext *nvv4l2_ctx = avctx->priv_data;
+    NvCodingType nv_codec_type = map_avcodec_id(avctx->codec_id);
+    int pix_fmt;
+
+    if (nv_codec_type == NvVideoCodec_UNDEFINED) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupported codec ID %d!\n",
+               avctx->codec_id);
+        return AVERROR_BUG;
+    }
+
+    switch (avctx->pix_fmt) {
+    case AV_PIX_FMT_NONE:
+    case AV_PIX_FMT_YUV420P:
+        avctx->pix_fmt = AV_PIX_FMT_YUV420P;
+        pix_fmt = V4L2_PIX_FMT_YUV420M;
+        break;
+    case AV_PIX_FMT_NV12:
+        pix_fmt = V4L2_PIX_FMT_NV12M;
+        break;
+    case AV_PIX_FMT_YUV420P10LE:
+    case AV_PIX_FMT_P010:
+        if (avctx->codec_id == AV_CODEC_ID_HEVC) {
+            avctx->pix_fmt = AV_PIX_FMT_YUV420P;
+            pix_fmt = V4L2_PIX_FMT_YUV420M;
+            break;
+        }
+    default:
+        av_log(avctx, AV_LOG_WARNING, "Unsupported pixel format %s!\n",
+               av_get_pix_fmt_name(avctx->pix_fmt));
+        return nvv4l2dec_codec_fallback(avctx);
+    }
+
+    nvv4l2_ctx->ctx = nvv4l2_create_decoder(avctx, nv_codec_type, pix_fmt);
+
+    if (!nvv4l2_ctx->ctx || nvv4l2_ctx->ctx->in_error) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to create nvv4l2 decoder!\n");
+
+        if (nvv4l2_ctx->ctx && nvv4l2_ctx->ctx->in_error) {
+            nvv4l2_decoder_close(avctx, nvv4l2_ctx->ctx);
+        }
+
+        return AVERROR_UNKNOWN;
+    }
+
+    /*
+     ** Check if low latency is needed.
+     ** Depends on whole frames received instead of slices.
+     ** Otherwise the decoder only starts streaming after a
+     ** required amount of packets received.
+     */
+    nvv4l2_ctx->ctx->low_latency =
+                (avctx->flags & AV_CODEC_FLAG_LOW_DELAY) ? true : false;
+
+    return 0;
+}
+
+static void nvv4l2dec_flush(AVCodecContext *avctx)
+{
+    nvv4l2DecodeContext *nvv4l2_ctx = avctx->priv_data;
+    nvv4l2_ctx_t *ctx = nvv4l2_ctx->ctx;
+    int ret = 0;
+
+    pthread_mutex_lock(&ctx->queue_lock);
+    /* Flush all queued buffers from output and capture plane. */
+    if (ctx->op_streamon && ctx->cp_streamon &&
+       (ctx->num_queued_op_buffers || ctx->num_active_op_buffers)) {
+        /* Stop streaming on both planes. */
+        v4l2_ioctl(ctx->fd, VIDIOC_STREAMOFF, &ctx->op_buf_type);
+        v4l2_ioctl(ctx->fd, VIDIOC_STREAMOFF, &ctx->cp_buf_type);
+        ctx->op_streamon = false;
+        ctx->cp_streamon = false;
+
+        /* Turn on output plane streaming. */
+        ret = v4l2_ioctl(ctx->fd, VIDIOC_STREAMON, &ctx->op_buf_type);
+        if (ret != 0) {
+            av_log(avctx, AV_LOG_ERROR, "Streaming error on output plane!\n");
+            ctx->in_error = true;
+        } else {
+            ctx->op_streamon = true;
+        }
+
+        ctx->draining_event = true;
+        ctx->num_active_op_buffers = 0;
+        ctx->num_queued_op_buffers = 0;
+        ctx->num_queued_cp_buffers = 0;
+
+        /* Turn on capture plane streaming. */
+        ret = v4l2_ioctl(ctx->fd, VIDIOC_STREAMON, &ctx->cp_buf_type);
+        if (ret != 0) {
+            av_log(avctx, AV_LOG_ERROR, "Streaming error on capture plane!\n");
+            ctx->in_error = true;
+        } else {
+            /* Re-enqueue all now empty buffers on capture plane. */
+            for (uint32_t i = 0; i < ctx->cp_num_buffers; i++) {
+                struct v4l2_buffer v4l2_buf;
+                struct v4l2_plane planes[NV_MAX_PLANES];
+
+                memset(&v4l2_buf, 0, sizeof(v4l2_buf));
+                memset(planes, 0, sizeof(planes));
+
+                v4l2_buf.index = i;
+                v4l2_buf.m.planes = planes;
+                v4l2_buf.type = ctx->cp_buf_type;
+                v4l2_buf.memory = ctx->cp_mem_type;
+                v4l2_buf.length = ctx->cp_num_planes;
+                /* Set DMA plane handle */
+                v4l2_buf.m.planes[0].m.fd = ctx->dmabuff_fd[i];
+                v4l2_buf.m.planes[1].m.fd = ctx->dmabuff_fd[i];
+
+                pthread_mutex_unlock(&ctx->queue_lock);
+                ret = nvv4l2_q_buffer(ctx, &v4l2_buf, ctx->cp_buffers[i],
+                                      ctx->cp_buf_type, ctx->cp_mem_type,
+                                      ctx->cp_num_planes);
+                pthread_mutex_lock(&ctx->queue_lock);
+
+                if (ret) {
+                    av_log(avctx, AV_LOG_WARNING,
+                           "Qing empty failed on capture plane!\n");
+                }
+            }
+
+            ctx->cp_streamon = true;
+        }
+    }
+
+    /* Flush all decoded frames from frame pool */
+    while (ctx->export_pool->capacity != 0) {
+        nvv4l2_pool_pop(ctx, ctx->export_pool);
+    }
+    ctx->export_pool->front = 0;
+    ctx->export_pool->back = 0;
+    pthread_mutex_unlock(&ctx->queue_lock);
+}
+
+static int nvv4l2dec_close(AVCodecContext *avctx)
+{
+    nvv4l2DecodeContext *nvv4l2_ctx = avctx->priv_data;
+    return nvv4l2_decoder_close(avctx, nvv4l2_ctx->ctx);
+}
+
+static int
+nvv4l2dec_decode(AVCodecContext *avctx, void *data, int *got_frame,
+                 AVPacket *avpkt)
+{
+    nvv4l2DecodeContext *nvv4l2_ctx = avctx->priv_data;
+    nvv4l2_ctx_t *ctx = nvv4l2_ctx->ctx;
+    AVFrame *avframe = (AVFrame *)data;
+    NvFrame _nvframe = { 0 };
+    int processed_size = 0;
+    int buf_index = -1;
+
+    if (ctx->in_error) {
+        return AVERROR_UNKNOWN;
+    }
+
+    if (avpkt->size) {
+        NvPacket packet;
+        packet.payload_size = avpkt->size;
+        packet.payload = avpkt->data;
+        packet.pts = avpkt->pts;
+        packet.user_pts = avctx->reordered_opaque;
+
+        if (!nvv4l2_decoder_put_packet(avctx, ctx, &packet)) {
+            processed_size = avpkt->size;
+        } else {
+            return AVERROR_UNKNOWN;
+        }
+    }
+
+    /* Get a decoded frame if any. */
+    if (nvv4l2_decoder_get_frame(avctx, ctx, &buf_index, &_nvframe))
+        return processed_size;
+
+    /* Set coded width to aligned size to fit the transformation.
+     ** It gets restored after transformation by default.
+     */
+    avctx->coded_width = ctx->plane_width_aligned;
+
+    /* Get frame data buffers. */
+    if (ff_get_buffer(avctx, avframe, 0) < 0)
+        return AVERROR(ENOMEM);
+
+    /* Export decoded frame data. */
+    if (buf_index >= 0 && avframe->data[0]) {
+        NvBuffer2Raw(ctx->plane_dma_fd[buf_index], 0,
+                     ctx->plane_width[0], ctx->plane_height[0],
+                     avframe->data[0]);
+        NvBuffer2Raw(ctx->plane_dma_fd[buf_index], 1,
+                     ctx->plane_width[1], ctx->plane_height[1],
+                     avframe->data[1]);
+        if (ctx->cp_pixfmt == V4L2_PIX_FMT_YUV420M) {
+            NvBuffer2Raw(ctx->plane_dma_fd[buf_index], 2,
+                         ctx->plane_width[2], ctx->plane_height[2],
+                         avframe->data[2]);
+        }
+    }
+
+    avframe->width = _nvframe.width;
+    avframe->height = _nvframe.height;
+
+    avframe->format = avctx->pix_fmt;
+    avframe->pkt_dts = AV_NOPTS_VALUE;
+
+    /* Decide which timestamps to set. */
+    if (_nvframe.pts != AV_NOPTS_VALUE) {
+        avframe->pts = _nvframe.pts;
+    } else {
+        avframe->pts = _nvframe.pts;
+        avframe->reordered_opaque = _nvframe.user_pts;
+    }
+
+    avframe->key_frame = 0;
+
+    avctx->coded_width = _nvframe.width;
+    avctx->coded_height = _nvframe.height;
+    avctx->width = _nvframe.width;
+    avctx->height = _nvframe.height;
+
+    *got_frame = 1;
+
+    return processed_size;
+}
+
+#define NVV4L2_DEC_CLASS(NAME)                         \
+    static const AVClass nvv4l2_##NAME##_dec_class = { \
+        .class_name = "nvv4l2_" #NAME "_dec",          \
+        .version    = LIBAVUTIL_VERSION_INT,           \
+    };
+
+#define NVV4L2_DEC(NAME, ID, BSFS)                                                    \
+    NVV4L2_DEC_CLASS(NAME)                                                            \
+    AVCodec ff_##NAME##_nvv4l2_decoder = {                                            \
+        .name           = #NAME "_nvv4l2",                                            \
+        .long_name      = NULL_IF_CONFIG_SMALL(#NAME " NVV4L2 HW decoder for Tegra"), \
+        .type           = AVMEDIA_TYPE_VIDEO,                                         \
+        .id             = ID,                                                         \
+        .priv_data_size = sizeof(nvv4l2DecodeContext),                                \
+        .init           = nvv4l2dec_init,                                             \
+        .close          = nvv4l2dec_close,                                            \
+        .decode         = nvv4l2dec_decode,                                           \
+        .flush          = nvv4l2dec_flush,                                            \
+        .priv_class     = &nvv4l2_##NAME##_dec_class,                                 \
+        .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE |                \
+                          AV_CODEC_CAP_AVOID_PROBING,                                 \
+        .bsfs           = BSFS,                                                       \
+        .wrapper_name   = "nvv4l2",                                                   \
+        .pix_fmts       =(const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P,            \
+                                                       AV_PIX_FMT_NV12,               \
+                                                       AV_PIX_FMT_NONE },             \
+    };
+
+NVV4L2_DEC(h264,  AV_CODEC_ID_H264,       "h264_mp4toannexb");
+NVV4L2_DEC(hevc,  AV_CODEC_ID_HEVC,       "hevc_mp4toannexb");
+NVV4L2_DEC(mpeg2, AV_CODEC_ID_MPEG2VIDEO, NULL);
+NVV4L2_DEC(mpeg4, AV_CODEC_ID_MPEG4,      NULL);
+NVV4L2_DEC(vp9,   AV_CODEC_ID_VP9,        NULL);
+NVV4L2_DEC(vp8,   AV_CODEC_ID_VP8,        NULL);
diff --git a/libavcodec/nvv4l2_enc.c b/libavcodec/nvv4l2_enc.c
new file mode 100644
index 0000000000..5102bd895d
--- /dev/null
+++ b/libavcodec/nvv4l2_enc.c
@@ -0,0 +1,1482 @@
+/*
+ * Copyright (c) 2021-2023, CTCaer <ctcaer@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include "internal.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/log.h"
+#include "libavutil/opt.h"
+
+#include "nvv4l2.h"
+
+#define ENCODER_DEV "/dev/nvhost-msenc"
+#define PACKET_DEFAULT_SIZE (2*1024*1024)
+
+/*
+ ** Output plane format support:
+ **  YM12 (YUV 4:2:0)
+ **  NM12 (YUV 4:2:0 interleaved)
+ **  YM24 (YUV 4:4:4)
+ **  PM10 (YUV 4:2:0 10-bit interleaved)
+ **
+ ** Capture plane format support:
+ **  H264 (H264 Encoded bitstream)
+ **  H265 (H265 Encoded bitstream)
+ **  VP80 (VP8  Encoded bitstream)
+ */
+
+/*
+ ** Output plane memory type support:
+ **  V4L2_MEMORY_MMAP
+ **  V4L2_MEMORY_DMABUF
+ ** Capture plane memory type support:
+ **  V4L2_MEMORY_MMAP
+ */
+
+typedef struct {
+    const AVClass *class;
+    nvv4l2_ctx_t *ctx;
+    int num_capture_buffers;
+    int profile;
+    int level;
+    int tier;
+    int rc;
+    int preset;
+    int lossless;
+    int twopass;
+} nvv4l2EncodeContext;
+
+static int
+set_output_plane_format(AVCodecContext *avctx, nvv4l2_ctx_t *ctx,
+                        uint32_t pixfmt, uint32_t width, uint32_t height)
+{
+    int ret;
+    struct v4l2_format format;
+    uint32_t num_bufferplanes;
+    NvBufferPlaneFormat planefmts[NV_MAX_PLANES];
+
+    /* Get plane format */
+    ret = nvv4l2_fill_buffer_plane_format(ctx, &num_bufferplanes, planefmts,
+                                          width, height, pixfmt);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Error getting output plane format!\n");
+        ctx->in_error = true;
+        return ret;
+    }
+    ctx->op_num_planes = num_bufferplanes;
+
+    /* Set plane format. */
+    for (uint32_t j = 0; j < num_bufferplanes; ++j) {
+        ctx->op_planefmts[j] = planefmts[j];
+    }
+    memset(&format, 0, sizeof(struct v4l2_format));
+    format.type = ctx->op_buf_type;
+    format.fmt.pix_mp.width = width;
+    format.fmt.pix_mp.height = height;
+    format.fmt.pix_mp.pixelformat = pixfmt;
+    format.fmt.pix_mp.num_planes = num_bufferplanes;
+
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_S_FMT, &format);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Error in setting output plane format!\n");
+        ctx->in_error = true;
+    } else {
+        ctx->op_num_planes = format.fmt.pix_mp.num_planes;
+        for (uint32_t j = 0; j < ctx->op_num_planes; j++) {
+            ctx->op_planefmts[j].stride =
+                format.fmt.pix_mp.plane_fmt[j].bytesperline;
+            ctx->op_planefmts[j].sizeimage =
+                format.fmt.pix_mp.plane_fmt[j].sizeimage;
+        }
+    }
+
+    return ret;
+}
+
+static int
+set_capture_plane_format(AVCodecContext *avctx, nvv4l2_ctx_t *ctx,
+                         uint32_t pixfmt, uint32_t width,
+                         uint32_t height, uint32_t sizeimage)
+{
+    int ret;
+    struct v4l2_format format;
+
+    memset(&format, 0, sizeof(struct v4l2_format));
+    format.type = ctx->cp_buf_type;
+    format.fmt.pix_mp.pixelformat = pixfmt;
+    format.fmt.pix_mp.width = width;
+    format.fmt.pix_mp.height = height;
+    format.fmt.pix_mp.num_planes = 1;
+    format.fmt.pix_mp.plane_fmt[0].sizeimage = sizeimage;
+
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_S_FMT, &format);
+
+    if (ret == 0) {
+        ctx->cp_num_planes = format.fmt.pix_mp.num_planes;
+        for (uint32_t i = 0; i < ctx->cp_num_planes; ++i) {
+            ctx->cp_planefmts[i].stride =
+                format.fmt.pix_mp.plane_fmt[i].bytesperline;
+            ctx->cp_planefmts[i].sizeimage =
+                format.fmt.pix_mp.plane_fmt[i].sizeimage;
+        }
+    } else {
+        av_log(avctx, AV_LOG_ERROR,
+               "Error in setting capture plane format!\n");
+        ctx->in_error = true;
+    }
+
+    return ret;
+}
+
+static void *enc_capture_thread(void *arg)
+{
+    nvv4l2_ctx_t *ctx = (nvv4l2_ctx_t *)arg;
+    uint32_t packet_size;
+    int buf_index;
+    int ret;
+
+    /* Check for EOS event in case stream finished. */
+    while (!ctx->in_error && !ctx->eos) {
+        /* Main Capture loop for DQ and Q. */
+        struct v4l2_buffer v4l2_cp_buf;
+        struct v4l2_plane capture_planes[NV_MAX_PLANES];
+        v4l2_ctrl_videoenc_outputbuf_metadata enc_metadata;
+        NvBuffer *cp_buffer = NULL;
+
+        memset(&v4l2_cp_buf, 0, sizeof(v4l2_cp_buf));
+        memset(capture_planes, 0, sizeof(capture_planes));
+        v4l2_cp_buf.m.planes = capture_planes;
+        v4l2_cp_buf.length = 1;
+
+        /* Dequeue the filled buffer. */
+        if (nvv4l2_dq_buffer(ctx, &v4l2_cp_buf, &cp_buffer,
+             ctx->cp_buf_type, ctx->cp_mem_type, 0)) {
+            if (errno == EAGAIN) {
+                usleep(1000);
+            }
+            continue;
+        }
+
+        packet_size = cp_buffer->planes[0].bytesused;
+
+        if (packet_size == 0) {
+            av_log(ctx->avctx, AV_LOG_ERROR,
+                   "Got 0 size buffer in capture!\n");
+            ctx->in_error = true;
+            break;
+        }
+
+        buf_index = nvv4l2_pool_idx_next(ctx, ctx->export_pool);
+
+        if (buf_index >= 0) {
+            /* Ensure packet buffer fits new packet */
+            if (ctx->packet_buf_size[buf_index] < packet_size) {
+                NVFREE(ctx->packet[buf_index]);
+                ctx->packet[buf_index] = (unsigned char *)NVMALLOC(packet_size);
+                ctx->packet_buf_size[buf_index] = packet_size;
+            }
+
+            ctx->packet_size[buf_index] = packet_size;
+            memcpy(ctx->packet[buf_index], cp_buffer->planes[0].data,
+                   packet_size);
+
+            ctx->frame_pts[buf_index] = v4l2_cp_buf.timestamp.tv_usec +
+                                        (v4l2_cp_buf.timestamp.tv_sec *
+                                         AV_TIME_BASE);
+
+            ret = nvv4l2_get_ext_control_metadata(ctx->fd,
+                                                  v4l2_cp_buf.index,
+                                                  &enc_metadata);
+            if (ret) {
+                av_log(ctx->avctx, AV_LOG_ERROR,
+                       "Failed getting metadata!\n");
+                ctx->in_error = true;
+                break;
+            }
+            ctx->packet_keyflag[buf_index] =
+                                    enc_metadata.KeyFrame ? true : false;
+        }
+
+        nvv4l2_pool_push(ctx, ctx->export_pool);
+
+        /* Queue the buffer. */
+        ret = nvv4l2_q_buffer(ctx, &v4l2_cp_buf, cp_buffer, ctx->cp_buf_type,
+                              ctx->cp_mem_type, ctx->cp_num_planes);
+
+        if (ret) {
+            av_log(ctx->avctx, AV_LOG_ERROR,
+                   "Qing failed on capture plane!\n");
+            ctx->in_error = true;
+            break;
+        }
+    }
+
+    av_log(ctx->avctx, AV_LOG_VERBOSE,
+           "Exiting encoder capture loop thread\n");
+
+    return NULL;
+}
+
+nvv4l2_ctx_t *nvv4l2_create_encoder(AVCodecContext *avctx,
+                                    NvEncoder *encoder,
+                                    NvCodingType nv_codec_type,
+                                    int pix_fmt)
+{
+    nvv4l2EncodeContext *nvv4l2_ctx = avctx->priv_data;
+
+    int ret;
+    int flags = 0;
+    nvv4l2_ctx_t *ctx = (nvv4l2_ctx_t *)NVCALLOC(1, sizeof(nvv4l2_ctx_t));
+    ctx->avctx = avctx;
+    ctx->enc = encoder;
+
+    /* The call creates a new V4L2 Video Decoder object
+     ** on the device node "/dev/nvhost-msenc"
+     ** Additional flags can also be given with which the device
+     ** should be opened.
+     ** This opens the device in Blocking mode.
+     */
+    ctx->fd = v4l2_open(ENCODER_DEV, flags | O_RDWR);
+    if (ctx->fd == -1) {
+        av_log(avctx, AV_LOG_ERROR, "Could not open device!\n");
+        ctx->in_error = true;
+        return ctx;
+    }
+
+    /* Initialization. */
+    ctx->codec_width = encoder->width;
+    ctx->codec_height = encoder->height;
+    ctx->low_latency = encoder->low_latency;
+    ctx->op_pixfmt = pix_fmt;
+    ctx->cp_pixfmt = nvv4l2_map_nvcodec_type(nv_codec_type);
+
+    /* Get NvBuffer pixel format list version */
+    ctx->pixfmt_list_ver = nvv4l2_get_pixfmt_list_version(ctx);
+
+    /* Encoder code assumes that the following do not change.
+     ** If another memory type is wanted, relevant changes should be done
+     ** to the rest of the code.
+     */
+    ctx->op_mem_type = V4L2_MEMORY_DMABUF;
+    ctx->cp_mem_type = V4L2_MEMORY_MMAP;
+
+    ctx->op_buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+    ctx->cp_buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+
+    for (uint32_t i = 0; i < NV_MAX_BUFFERS; i++)
+        ctx->plane_dma_fd[i] = -1;
+
+    /* Allocate packet pool. */
+    ctx->export_pool = (NvQueues *)NVCALLOC(1, sizeof(NvQueues));
+    for(int index = 0; index < NV_MAX_BUFFERS; index++) {
+        ctx->packet[index] = (unsigned char *)NVMALLOC(PACKET_DEFAULT_SIZE);
+        ctx->packet_buf_size[index] = PACKET_DEFAULT_SIZE;
+    }
+
+    /* Initialize mutexes */
+    pthread_mutex_init(&ctx->queue_lock, NULL);
+    pthread_cond_init(&ctx->queue_cond, NULL);
+
+    /* Set format on capture plane. */
+    ret = set_capture_plane_format(avctx, ctx, ctx->cp_pixfmt,
+                                   ctx->codec_width, ctx->codec_height,
+                                   PACKET_DEFAULT_SIZE);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Error in setting capture plane format!\n");
+        ctx->in_error = true;
+    }
+
+    /* Set format on output plane. */
+    ret = set_output_plane_format(avctx, ctx, ctx->op_pixfmt,
+                                  ctx->codec_width, ctx->codec_height);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Error in setting output plane format!\n");
+        ctx->in_error = true;
+    }
+
+    /* Set max performance mode if low latency is requested. */
+    if (ctx->low_latency) {
+        ret =
+        nvv4l2_set_ext_controls(ctx->fd,
+                                V4L2_CID_MPEG_VIDEO_MAX_PERFORMANCE, 0, 1);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Failed to set control max performance!\n");
+            ctx->in_error = true;
+        }
+    }
+
+    /* Set encoder bitrate. */
+    ret = nvv4l2_set_ext_controls(ctx->fd, V4L2_CID_MPEG_VIDEO_BITRATE,
+                                  V4L2_CTRL_CLASS_MPEG,
+                                  ctx->enc->bitrate);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Failed to set encoder bitrate!\n");
+        ctx->in_error = true;
+    }
+
+    /* Set encoder HW Preset Type. */
+    ret = nvv4l2_set_ext_controls(ctx->fd,
+                                  V4L2_CID_MPEG_VIDEOENC_HW_PRESET_TYPE_PARAM,
+                                  V4L2_CTRL_CLASS_MPEG,
+                                  ctx->enc->preset_type);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Failed to set encoder HW Preset Type!\n");
+        ctx->in_error = true;
+    }
+
+    /* Set number of reference frames. */
+    if (ctx->enc->num_ref) {
+        ret = nvv4l2_set_ext_controls(ctx->fd,
+                                V4L2_CID_MPEG_VIDEOENC_NUM_REFERENCE_FRAMES,
+                                V4L2_CTRL_CLASS_MPEG,
+                                ctx->enc->num_ref);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Failed to set num reference frames!\n");
+            ctx->in_error = true;
+        }
+    }
+
+    /* Set number of B Frames. */
+    if (ctx->enc->num_b_frames && nv_codec_type == NvVideoCodec_H264) {
+        ret = nvv4l2_set_ext_controls(ctx->fd,
+                                      V4L2_CID_MPEG_VIDEOENC_NUM_BFRAMES,
+                                      V4L2_CTRL_CLASS_MPEG,
+                                      ctx->enc->num_b_frames);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Failed to set number of B Frames!\n");
+            ctx->in_error = true;
+        }
+    }
+
+    /* Set encoder profile. */
+    ret = nvv4l2_set_ext_controls(ctx->fd, nv_codec_type == NvVideoCodec_H264 ?
+                                  V4L2_CID_MPEG_VIDEO_H264_PROFILE :
+                                  V4L2_CID_MPEG_VIDEO_H265_PROFILE,
+                                  V4L2_CTRL_CLASS_MPEG,
+                                  ctx->enc->profile);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Failed to set encoder profile!\n");
+        ctx->in_error = true;
+    }
+
+    /* Set encoder level. */
+    ret = nvv4l2_set_ext_controls(ctx->fd, nv_codec_type == NvVideoCodec_H264 ?
+                                  V4L2_CID_MPEG_VIDEO_H264_LEVEL :
+                                  V4L2_CID_MPEG_VIDEOENC_H265_LEVEL,
+                                  V4L2_CTRL_CLASS_MPEG,
+                                  ctx->enc->level);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Failed to set encoder level!\n");
+        ctx->in_error = true;
+    }
+
+    if (!ctx->enc->lossless) {
+        /* Set encoder rate control mode. */
+        ret = nvv4l2_set_ext_controls(ctx->fd, V4L2_CID_MPEG_VIDEO_BITRATE_MODE,
+                                      V4L2_CTRL_CLASS_MPEG,
+                                      ctx->enc->ratecontrol);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Failed to set encoder rate control mode!\n");
+            ctx->in_error = true;
+        }
+
+        /* Set encoder max bitrate for VBR. */
+        if (ctx->enc->ratecontrol == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR) {
+
+            uint32_t max_bitrate = 1.2f * ctx->enc->bitrate;
+            ret = nvv4l2_set_ext_controls(ctx->fd,
+                                          V4L2_CID_MPEG_VIDEO_BITRATE_PEAK,
+                                          V4L2_CTRL_CLASS_MPEG,
+                                          max_bitrate);
+            if (ret) {
+                av_log(avctx, AV_LOG_ERROR,
+                       "Failed to set encoder max bitrate for VBR!\n");
+                ctx->in_error = true;
+            }
+        }
+    } else {
+        /* Set constant qp configuration for lossless encoding enabled */
+        ret = nvv4l2_set_ext_control_constant_qp(ctx->fd, 0);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Failed to set encoder qp to 0 for lossless encoding!\n");
+            ctx->in_error = true;
+        }
+    }
+
+    /* Set Two-pass CBR mode. */
+    if (ctx->enc->twopass) {
+        /* Set encoder IDR interval. */
+        ret = nvv4l2_set_ext_controls(ctx->fd,
+                                      V4L2_CID_MPEG_VIDEOENC_TWO_PASS_CBR,
+                                      V4L2_CTRL_CLASS_MPEG,
+                                      1);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Failed to set encoder 2-pass cbr!\n");
+            ctx->in_error = true;
+        }
+    }
+
+    /* Set encoder IDR interval. */
+    ret = nvv4l2_set_ext_controls(ctx->fd, V4L2_CID_MPEG_VIDEO_IDR_INTERVAL,
+                                  V4L2_CTRL_CLASS_MPEG,
+                                  ctx->enc->idr_interval);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Failed to set encoder IDR interval!\n");
+        ctx->in_error = true;
+    }
+
+    /* Set encoder quantization parameters. */
+    if (ctx->enc->qmin != -1 || ctx->enc->qmax != -1) {
+        ret = nvv4l2_set_ext_control_qp_range(ctx->fd,
+                                              ctx->enc->qmin, ctx->enc->qmax);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Failed to set encoder quantization parameters!\n");
+            ctx->in_error = true;
+        }
+    }
+
+    /* Set encoder I-Frame interval. */
+    ret = nvv4l2_set_ext_controls(ctx->fd, V4L2_CID_MPEG_VIDEO_GOP_SIZE,
+                                  V4L2_CTRL_CLASS_MPEG,
+                                  ctx->enc->iframe_interval);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Failed to set encoder I-Frame interval!\n");
+        ctx->in_error = true;
+    }
+
+    /* Set insertSPSPPSAtIDR. */
+    if (ctx->enc->sps_pps_at_idr) {
+        ret = nvv4l2_set_ext_controls(ctx->fd,
+                                V4L2_CID_MPEG_VIDEOENC_INSERT_SPS_PPS_AT_IDR,
+                                V4L2_CTRL_CLASS_MPEG,
+                                1);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Failed to set insertSPSPPSAtIDR!\n");
+            ctx->in_error = true;
+        }
+    }
+
+    /* Set encoder framerate. */
+    ret = nvv4l2_set_stream_control_framerate(ctx->fd,
+                                              ctx->op_mem_type,
+                                              ctx->enc->fps_n,
+                                              ctx->enc->fps_d);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Failed to set framerate!\n");
+        ctx->in_error = true;
+    }
+
+    /* Request max 10 buffers on output plane.
+     ** Number of received buffers normally is lower (6). */
+    ret = nvv4l2_req_buffers_on_output_plane(ctx,
+                                             ctx->op_buf_type,
+                                             ctx->op_mem_type,
+                                             10);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Error in requesting buffers on output plane!\n");
+        ctx->in_error = true;
+    }
+
+    /* Create import DMA buffers. */
+    for (uint32_t i = 0; i < ctx->op_num_buffers; i++) {
+        NvBufferCreateParams iParams;
+        memset(&iParams, 0, sizeof(NvBufferCreateParams));
+        iParams.width = ctx->codec_width;
+        iParams.height = ctx->codec_height;
+        iParams.layout = NvBufferLayout_Pitch;
+        iParams.payloadType = NvBufferPayload_SurfArray;
+        iParams.nvbuf_tag = NvBufferTag_VIDEO_ENC;
+        switch (ctx->op_pixfmt) {
+        case V4L2_PIX_FMT_YUV444M:
+            iParams.colorFormat = NvBufferColorFormat_YUV444;
+            break;
+        case V4L2_PIX_FMT_P010M:
+            iParams.layout = NvBufferLayout_BlockLinear;
+            iParams.colorFormat = NvBufferColorFormat_NV12_10LE;
+            break;
+        case V4L2_PIX_FMT_NV12M:
+            iParams.colorFormat = NvBufferColorFormat_NV12;
+            break;
+        default:
+            iParams.colorFormat = NvBufferColorFormat_YUV420;
+            break;
+        }
+
+        if (ctx->enc->profile == V4L2_MPEG_VIDEO_H265_PROFILE_MAIN10) {
+            iParams.layout = NvBufferLayout_BlockLinear;
+            iParams.colorFormat = NvBufferColorFormat_NV12_10LE;
+        }
+
+        /* Increment color format if NvBuffer is newer. */
+        if (ctx->pixfmt_list_ver == NvBufferPixFmtVersion_New &&
+             iParams.colorFormat > NvBufferColorFormat_YUV420) {
+            iParams.colorFormat++;
+        }
+
+        ret = NvBufferCreateEx(&ctx->plane_dma_fd[i], &iParams);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR, "Creation of dmabuf failed!\n");
+            ctx->in_error = true;
+        }
+    }
+
+    /* Request buffers on capture plane. */
+    ret = nvv4l2_req_buffers_on_capture_plane(ctx,
+                                         ctx->cp_buf_type,
+                                         ctx->cp_mem_type,
+                                         nvv4l2_ctx->num_capture_buffers);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Error in requesting buffers on capture plane!\n");
+        ctx->in_error = true;
+    }
+
+    /* Map buffers on capture plane */
+    for (uint32_t i = 0; i < ctx->cp_num_buffers; i++) {
+        ret = nvv4l2_query_buffer(ctx, ctx->cp_buf_type,
+                                  ctx->cp_mem_type, ctx->cp_num_planes, i);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Failed to query buffer on capture plane!\n");
+            ctx->in_error = true;
+        }
+        ret = nvv4l2_export_buffer(ctx, ctx->cp_buf_type,
+                                   ctx->cp_num_planes, i);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Failed to export buffer on capture plane!\n");
+            ctx->in_error = true;
+        }
+        ret = nvv4l2_map(ctx, ctx->cp_buffers[i]);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Failed to map buffer on capture plane!\n");
+            ctx->in_error = true;
+        }
+    }
+
+    /* Start stream processing on output plane. */
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_STREAMON, &ctx->op_buf_type);
+    if (ret != 0) {
+        av_log(avctx, AV_LOG_ERROR, "Streaming error on output plane!\n");
+        ctx->in_error = true;
+    }
+    ctx->op_streamon = true;
+
+     /* Set streaming status ON on capture plane. */
+    ret = v4l2_ioctl(ctx->fd, VIDIOC_STREAMON, &ctx->cp_buf_type);
+    if (ret != 0) {
+        av_log(avctx, AV_LOG_ERROR, "Streaming error on capture plane!\n");
+        ctx->in_error = true;
+    }
+    ctx->cp_streamon = true;
+
+    /* Create and start capture loop thread. */
+    pthread_create(&ctx->capture_thread, NULL, enc_capture_thread, ctx);
+
+    /* Enqueue all the empty capture plane buffers. */
+    for (uint32_t i = 0; i < ctx->cp_num_buffers; i++){
+        struct v4l2_buffer v4l2_buf;
+        struct v4l2_plane planes[NV_MAX_PLANES];
+        memset(&v4l2_buf, 0, sizeof(v4l2_buf));
+        memset(planes, 0, NV_MAX_PLANES * sizeof(struct v4l2_plane));
+
+        v4l2_buf.index = i;
+        v4l2_buf.m.planes = planes;
+
+        ret = nvv4l2_q_buffer(ctx, &v4l2_buf, ctx->cp_buffers[i],
+                              ctx->cp_buf_type, ctx->cp_mem_type,
+                              ctx->cp_num_planes);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR, "Qing failed on capture plane!\n");
+            ctx->in_error = true;
+        }
+    }
+
+    return ctx;
+}
+
+int nvv4l2_encoder_put_frame(AVCodecContext *avctx, nvv4l2_ctx_t *ctx,
+                             NvFrame *frame)
+{
+    int ret;
+    int alignment;
+    struct v4l2_buffer v4l2_buf_op;
+    struct v4l2_plane queue_op_planes[NV_MAX_PLANES];
+    NvBuffer *buffer;
+    memset(&v4l2_buf_op, 0, sizeof(v4l2_buf_op));
+    memset(queue_op_planes, 0, sizeof(queue_op_planes));
+    v4l2_buf_op.m.planes = queue_op_planes;
+
+    if (ctx->in_error)
+        return -1;
+
+    if (ctx->num_active_op_buffers < ctx->op_num_buffers) {
+        /* Get an unused buffer to add to the queue. */
+        buffer = ctx->op_buffers[ctx->num_active_op_buffers];
+        v4l2_buf_op.index = ctx->num_active_op_buffers;
+
+        /* Map new plane buffer for memory type DMABUF. */
+        v4l2_buf_op.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+        v4l2_buf_op.memory = ctx->op_mem_type;
+        ret = nvv4l2_map_out(ctx, &v4l2_buf_op, ctx->op_buf_type,
+                             ctx->op_mem_type,
+                             ctx->plane_dma_fd[v4l2_buf_op.index]);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Error while mapping buffer at output plane!\n");
+            ctx->in_error = true;
+            return -1;
+        }
+    } else {
+        /* Dequeue a finished buffer and reuse it. */
+        ret = nvv4l2_dq_buffer(ctx, &v4l2_buf_op, &buffer,
+                               ctx->op_buf_type, ctx->op_mem_type, -1);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Error DQing buffer at output plane!\n");
+            ctx->in_error = true;
+            return -1;
+        }
+    }
+
+    /*
+     ** Due to NvMap/VIC stride conversion constrains, the transformation
+     ** must be aligned per format/plane. Otherwise the frame might be
+     ** produced as scrambled.
+     **
+     ** !TODO: Have a proper algorithm to calculate needed alignements.
+     */
+    switch (ctx->op_pixfmt) {
+    case V4L2_PIX_FMT_NV12M:
+        alignment = 16;
+        break;
+    case V4L2_PIX_FMT_YUV420M:
+        alignment = 64;
+        break;
+    case V4L2_PIX_FMT_YUV444M:
+        alignment = 32;
+        break;
+    case V4L2_PIX_FMT_P010M:
+    default:
+        alignment = 1;
+        break;
+    }
+
+    /* Import frame into output plane */
+    for (uint32_t i = 0; i < buffer->n_planes; i++) {
+        int aligned_plane_width = NVALIGN(ctx->op_planefmts[i].width, alignment);
+
+        /* If plane is reduced, use alignment of main plane */
+        if (ctx->op_planefmts[i].width == ctx->op_planefmts[0].width / 2)
+            aligned_plane_width = NVALIGN(ctx->op_planefmts[0].width, alignment) / 2;
+
+        av_log(avctx, AV_LOG_VERBOSE, "Plane %d: width %d -> %d\n",
+               i, ctx->op_planefmts[i].width, aligned_plane_width);
+
+        Raw2NvBuffer(frame->payload[i], i, aligned_plane_width,
+                     ctx->op_planefmts[i].height, buffer->planes[i].fd);
+        buffer->planes[i].bytesused = ctx->op_planefmts[i].width *
+                                      ctx->op_planefmts[i].height *
+                                      ctx->op_planefmts[i].bytesperpixel;
+        v4l2_buf_op.m.planes[i].bytesused = buffer->planes[i].bytesused;
+    }
+
+    /* Set timestamp */
+    v4l2_buf_op.flags |= V4L2_BUF_FLAG_TIMESTAMP_COPY;
+    v4l2_buf_op.timestamp.tv_usec = frame->pts % AV_TIME_BASE;
+    v4l2_buf_op.timestamp.tv_sec = frame->pts / AV_TIME_BASE;
+
+    /* Queue frame on output plane. */
+    ret = nvv4l2_q_buffer(ctx, &v4l2_buf_op, buffer,
+                   ctx->op_buf_type, ctx->op_mem_type, ctx->op_num_planes);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR, "Error Qing buffer at output plane!\n");
+        ctx->in_error = true;
+        return -1;
+    }
+
+    if (ctx->num_active_op_buffers < ctx->op_num_buffers) {
+        ctx->num_active_op_buffers++;
+    }
+
+    return 0;
+}
+
+int nvv4l2_encoder_get_packet(AVCodecContext *avctx,
+                              nvv4l2_ctx_t *ctx,
+                              NvPacket *packet)
+{
+    int packet_index;
+
+    if (ctx->export_pool->capacity == 0)
+        return 1;
+
+    packet_index = nvv4l2_pool_pop(ctx, ctx->export_pool);
+
+    packet->payload = ctx->packet[packet_index];
+    packet->payload_size = ctx->packet_size[packet_index];
+    packet->pts = ctx->frame_pts[packet_index];
+
+    if (ctx->packet_keyflag[packet_index])
+        packet->flags |= AV_PKT_FLAG_KEY;
+
+    return 0;
+}
+
+int nvv4l2_encoder_close(AVCodecContext *avctx, nvv4l2_ctx_t *ctx)
+{
+    int ret, op_num_old_buffers;
+
+    if (!ctx)
+        return 0;
+
+    pthread_mutex_lock(&ctx->queue_lock);
+    ctx->eos = true;
+    pthread_mutex_unlock(&ctx->queue_lock);
+    if (ctx->fd != -1) {
+        /* Stop streaming on both planes. */
+        ret = v4l2_ioctl(ctx->fd, VIDIOC_STREAMOFF, &ctx->op_buf_type);
+        ret = v4l2_ioctl(ctx->fd, VIDIOC_STREAMOFF, &ctx->cp_buf_type);
+
+        /* Wait for capture thread to exit. */
+        if (ctx->capture_thread) {
+            pthread_join(ctx->capture_thread, NULL);
+        }
+
+        /* Unmap MMAPed buffers. */
+        for (uint32_t i = 0; i < ctx->cp_num_buffers; ++i) {
+            nvv4l2_destroyBuffer(ctx, ctx->cp_buffers[i]);
+        }
+
+        for (uint32_t i = 0; i < ctx->op_num_buffers; i++) {
+            if (ctx->plane_dma_fd[i] != -1) {
+                nvv4l2_unmap_out(ctx, i, ctx->op_buf_type,
+                                 ctx->op_mem_type, ctx->plane_dma_fd[i]);
+            }
+        }
+
+        /* Request 0 buffers on both planes. */
+        op_num_old_buffers = ctx->op_num_buffers;
+        ret = nvv4l2_req_buffers_on_output_plane(ctx,
+                                                 ctx->op_buf_type,
+                                                 ctx->op_mem_type, 0);
+
+        ret = nvv4l2_req_buffers_on_capture_plane(ctx,
+                                                  ctx->cp_buf_type,
+                                                  ctx->cp_mem_type, 0);
+
+        /* Unmap and destroy all allocated DMA buffers. */
+        for (uint32_t i = 0; i < op_num_old_buffers; i++) {
+            if (ctx->plane_dma_fd[i] != -1) {
+                ret = NvBufferDestroy(ctx->plane_dma_fd[i]);
+                ctx->plane_dma_fd[i] = -1;
+                if (ret) {
+                    av_log(avctx, AV_LOG_ERROR,
+                           "Failed to destroy output plane dma buffer!\n");
+                }
+            }
+        }
+
+        /* Free packet pool */
+        for (int index = 0; index < NV_MAX_BUFFERS; index++) {
+            NVFREE(ctx->packet[index]);
+        }
+        NVFREE(ctx->export_pool);
+
+        /* Close the opened V4L2 device. */
+        ret = v4l2_close(ctx->fd);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR, "Unable to close the device!\n");
+        }
+
+        /* Free mutexes */
+        pthread_mutex_destroy(&ctx->queue_lock);
+        pthread_cond_destroy(&ctx->queue_cond);
+    }
+
+    /* Free encoder parameters */
+    NVFREE(ctx->enc);
+
+    /* Report application run status on exit. */
+    if (ctx->in_error) {
+        av_log(avctx, AV_LOG_ERROR, "Encoder Run failed\n");
+    } else {
+        av_log(avctx, AV_LOG_VERBOSE, "Encoder Run is successful\n");
+    }
+
+    NVFREE(ctx);
+
+    return ret;
+}
+
+static void
+nvv4l2_set_h264_profile_params(nvv4l2EncodeContext *nvv4l2_ctx,
+                               NvEncoder *enc,
+                               int *pix_fmt)
+{
+    switch (nvv4l2_ctx->profile & ~FF_PROFILE_H264_INTRA) {
+    case FF_PROFILE_H264_MAIN:
+        enc->profile = V4L2_MPEG_VIDEO_H264_PROFILE_MAIN;
+        break;
+    case FF_PROFILE_H264_BASELINE:
+        enc->profile = V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE;
+        break;
+    case FF_PROFILE_H264_HIGH:
+        enc->profile = V4L2_MPEG_VIDEO_H264_PROFILE_HIGH;
+        break;
+    case FF_PROFILE_H264_HIGH_444_PREDICTIVE:
+        enc->profile = V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_PREDICTIVE;
+        break;
+
+    default:
+        enc->profile = V4L2_MPEG_VIDEO_H264_PROFILE_MAIN;
+        break;
+    }
+
+    if (enc->lossless && *pix_fmt == V4L2_PIX_FMT_YUV444M)
+        enc->profile = V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_PREDICTIVE;
+
+    switch (nvv4l2_ctx->level) {
+    case 9:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_1B;
+        break;
+    case 10:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_1_0;
+        break;
+    case 11:
+        if (nvv4l2_ctx->profile & FF_PROFILE_H264_INTRA)
+            enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_1B;
+        else
+            enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_1_1;
+        break;
+    case 12:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_1_2;
+        break;
+    case 13:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_1_3;
+        break;
+    case 20:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_2_0;
+        break;
+    case 21:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_2_1;
+        break;
+    case 22:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_2_2;
+        break;
+    case 30:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_3_0;
+        break;
+    case 31:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_3_1;
+        break;
+    case 32:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_3_2;
+        break;
+    case 40:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_4_0;
+        break;
+    case 41:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_4_1;
+        break;
+    case 42:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_4_2;
+        break;
+    case 50:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_5_0;
+        break;
+    case 51:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_5_1;
+        break;
+    default:
+        enc->level = V4L2_MPEG_VIDEO_H264_LEVEL_5_1;
+        break;
+    }
+}
+
+static void
+nvv4l2_set_hevc_profile_params(nvv4l2EncodeContext *nvv4l2_ctx,
+                               NvEncoder *enc,
+                               int *pix_fmt)
+{
+    switch (nvv4l2_ctx->profile & ~FF_PROFILE_H264_INTRA) {
+    case FF_PROFILE_HEVC_MAIN:
+        enc->profile = V4L2_MPEG_VIDEO_H265_PROFILE_MAIN;
+        break;
+    case FF_PROFILE_HEVC_MAIN_10:
+        enc->profile = V4L2_MPEG_VIDEO_H265_PROFILE_MAIN10;
+        *pix_fmt = V4L2_PIX_FMT_P010M;
+        break;
+
+    default:
+        enc->profile = V4L2_MPEG_VIDEO_H265_PROFILE_MAIN;
+        break;
+    }
+
+    if (*pix_fmt == V4L2_PIX_FMT_P010M)
+        enc->profile = V4L2_MPEG_VIDEO_H265_PROFILE_MAIN10;
+
+    switch (nvv4l2_ctx->tier) {
+    case 0:
+    case 1:
+        enc->tier = nvv4l2_ctx->tier;
+        break;
+
+    default:
+        enc->tier = 0;
+        break;
+    }
+
+    switch (nvv4l2_ctx->level) {
+    case 30:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_1_0_MAIN_TIER;
+        break;
+    case 60:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_2_0_MAIN_TIER;
+        break;
+    case 63:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_2_1_MAIN_TIER;
+        break;
+    case 90:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_3_0_MAIN_TIER;
+        break;
+    case 93:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_3_1_MAIN_TIER;
+        break;
+    case 120:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_4_0_MAIN_TIER;
+        break;
+    case 123:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_4_1_MAIN_TIER;
+        break;
+    case 150:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_5_0_MAIN_TIER;
+        break;
+    case 153:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_5_1_MAIN_TIER;
+        break;
+    case 156:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_5_2_MAIN_TIER;
+        break;
+    case 180:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_6_0_MAIN_TIER;
+        break;
+    case 183:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_6_1_MAIN_TIER;
+        break;
+    case 186:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_6_2_MAIN_TIER;
+        break;
+    default:
+        enc->level = V4L2_MPEG_VIDEO_H265_LEVEL_6_2_MAIN_TIER;
+        break;
+    }
+
+    enc->level += enc->tier;
+}
+
+static NvEncoder *set_encoder_parameters(AVCodecContext *avctx,
+                                         nvv4l2EncodeContext *nvv4l2_ctx,
+                                         NvCodingType nv_codec_type,
+                                         int *pix_fmt)
+{
+    NvEncoder *enc = (NvEncoder *)NVCALLOC(1, sizeof(NvEncoder));
+
+    enc->lossless = nvv4l2_ctx->lossless;
+    enc->ratecontrol = nvv4l2_ctx->rc == 1 ?
+                            V4L2_MPEG_VIDEO_BITRATE_MODE_VBR :
+                            V4L2_MPEG_VIDEO_BITRATE_MODE_CBR;
+    if (nvv4l2_ctx->twopass) {
+        enc->twopass = 1;
+        enc->ratecontrol = V4L2_MPEG_VIDEO_BITRATE_MODE_CBR;
+    }
+
+    enc->width = avctx->width;
+    enc->height = avctx->height;
+    enc->bitrate = avctx->bit_rate;
+
+    if (nv_codec_type == NvVideoCodec_H264) {
+        nvv4l2_set_h264_profile_params(nvv4l2_ctx, enc, pix_fmt);
+    } else if (nv_codec_type == NvVideoCodec_HEVC) {
+        nvv4l2_set_hevc_profile_params(nvv4l2_ctx, enc, pix_fmt);
+    }
+
+    switch (nvv4l2_ctx->preset) {
+    case 1:
+        enc->preset_type = V4L2_ENC_HW_PRESET_ULTRAFAST;
+        break;
+    case 2:
+        enc->preset_type = V4L2_ENC_HW_PRESET_FAST;
+        break;
+    case 3:
+        enc->preset_type = V4L2_ENC_HW_PRESET_MEDIUM;
+        break;
+    case 4:
+        enc->preset_type = V4L2_ENC_HW_PRESET_SLOW;
+        break;
+    default:
+        enc->preset_type = V4L2_ENC_HW_PRESET_MEDIUM;
+        break;
+    }
+
+    if (avctx->gop_size > 0) {
+        enc->idr_interval = avctx->gop_size;
+        enc->iframe_interval = avctx->gop_size;
+    } else {
+        enc->idr_interval = 60;
+        enc->iframe_interval = 30;
+    }
+    enc->fps_n = avctx->framerate.num;
+    enc->fps_d = avctx->framerate.den;
+
+    if (avctx->qmin >= 0 && avctx->qmax >= 0) {
+        enc->qmin = avctx->qmin;
+        enc->qmax = avctx->qmax;
+    } else {
+        enc->qmin = -1;
+        enc->qmax = -1;
+    }
+
+    if (avctx->max_b_frames >= 0 && avctx->max_b_frames < 3)
+        enc->num_b_frames = avctx->max_b_frames;
+
+    if (avctx->refs > 0)
+        enc->num_ref = avctx->refs;
+
+    enc->sps_pps_at_idr = !(avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER);
+    enc->low_latency = (avctx->flags & AV_CODEC_FLAG_LOW_DELAY) ? true : false;
+
+    return enc;
+}
+
+static NvCodingType map_avcodec_id(enum AVCodecID id)
+{
+    switch (id) {
+    case AV_CODEC_ID_H264:
+        return NvVideoCodec_H264;
+    case AV_CODEC_ID_HEVC:
+        return NvVideoCodec_HEVC;
+    }
+    return NvVideoCodec_UNDEFINED;
+}
+
+static int nvv4l2enc_init(AVCodecContext *avctx)
+{
+    nvv4l2EncodeContext *nvv4l2_ctx = avctx->priv_data;
+    NvCodingType nv_codec_type;
+    NvEncoder *encoder;
+    int pix_fmt;
+
+    nv_codec_type = map_avcodec_id(avctx->codec_id);
+    if (nv_codec_type == NvVideoCodec_UNDEFINED) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupported codec ID %d!\n",
+               avctx->codec_id);
+        return AVERROR_BUG;
+    }
+
+    /* Set output plane pixel format. */
+    switch (avctx->pix_fmt) {
+    case AV_PIX_FMT_YUV444P:
+        pix_fmt = V4L2_PIX_FMT_YUV444M;
+        break;
+    case AV_PIX_FMT_NV12:
+        pix_fmt = V4L2_PIX_FMT_NV12M;
+        break;
+    case AV_PIX_FMT_YUV420P10:
+        avctx->pix_fmt = AV_PIX_FMT_P010;
+    case AV_PIX_FMT_P010:
+        pix_fmt = V4L2_PIX_FMT_P010M;
+        break;
+    case AV_PIX_FMT_NONE:
+        avctx->pix_fmt = AV_PIX_FMT_YUV420P;
+    case AV_PIX_FMT_YUV420P:
+        pix_fmt = V4L2_PIX_FMT_YUV420M;
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "Unsupported pixel format %d!\n",
+               avctx->pix_fmt);
+        return AVERROR_BUG;
+    }
+
+    /* Set encoder parameters. */
+    encoder = set_encoder_parameters(avctx, nvv4l2_ctx, nv_codec_type,
+                                     &pix_fmt);
+
+    /* Check if global SPS/PPS header is required and sample it. */
+    if (nv_codec_type == NvVideoCodec_H264 &&
+        (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER)) {
+        NvFrame _nvframe = {0};
+        NvPacket packet = {0};
+        uint8_t *dst[4];
+        int linesize[4];
+        int header_size = 0;
+        int ret = 0;
+
+        nvv4l2_ctx->ctx = nvv4l2_create_encoder(avctx, encoder,
+                                                NvVideoCodec_H264,
+                                                pix_fmt);
+        if (!nvv4l2_ctx->ctx || nvv4l2_ctx->ctx->in_error) {
+            ret = 1;
+            goto out;
+        }
+
+        /* Get a blank packet to extract metadata */
+        av_image_alloc(dst, linesize, avctx->width, avctx->height,
+                       avctx->pix_fmt, 1);
+
+        while (true) {
+            _nvframe.payload[0] = dst[0];
+            _nvframe.payload[1] = dst[1];
+            _nvframe.payload[2] = dst[2];
+
+            ret = nvv4l2_encoder_put_frame(avctx, nvv4l2_ctx->ctx, &_nvframe);
+            if (ret)
+                goto out;
+
+            /* Try several times to get a packet before queuing a new one. */
+            for (uint32_t i = 0; i < 100; i++) {
+                ret = nvv4l2_encoder_get_packet(avctx, nvv4l2_ctx->ctx,
+                                                &packet);
+                if (!ret)
+                    break;
+                usleep(1000);
+            }
+            if (ret)
+                continue;
+
+            /* Find H264_NAL_IDR_SLICE */
+            for (header_size = 0;
+                 (header_size + 4) < packet.payload_size;
+                 header_size++) {
+                if (packet.payload[header_size]     == 0 &&
+                    packet.payload[header_size + 1] == 0 &&
+                    packet.payload[header_size + 2] == 0 &&
+                    packet.payload[header_size + 3] == 1 &&
+                    packet.payload[header_size + 4] == 0x65) {
+                    break;
+                }
+            }
+
+            if (header_size >= packet.payload_size) {
+                av_log(avctx, AV_LOG_ERROR, "Header was not found!\n");
+                return AVERROR_BUG;
+            }
+
+            avctx->extradata_size = header_size;
+            avctx->extradata = av_mallocz(header_size +
+                                          AV_INPUT_BUFFER_PADDING_SIZE);
+            memcpy(avctx->extradata, packet.payload, header_size);
+
+            break;
+        }
+        av_free(dst[0]);
+
+out:
+        nvv4l2_encoder_close(avctx, nvv4l2_ctx->ctx);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR, "Error in initializing!\n");
+            return AVERROR_BUG;
+        }
+
+        /* Set encoder parameters again */
+        encoder = set_encoder_parameters(avctx, nvv4l2_ctx, nv_codec_type,
+                                         &pix_fmt);
+    }
+
+    nvv4l2_ctx->ctx = nvv4l2_create_encoder(avctx, encoder, nv_codec_type,
+                                            pix_fmt);
+
+    if (!nvv4l2_ctx->ctx || nvv4l2_ctx->ctx->in_error) {
+        nvv4l2_encoder_close(avctx, nvv4l2_ctx->ctx);
+        return AVERROR_BUG;
+    } else
+        return 0;
+}
+
+static int
+nvv4l2enc_encode(AVCodecContext *avctx, AVPacket *pkt,
+                 const AVFrame *frame, int *got_packet)
+{
+    nvv4l2EncodeContext *nvv4l2_ctx = avctx->priv_data;
+    nvv4l2_ctx_t *ctx = nvv4l2_ctx->ctx;
+    NvFrame _nvframe = {0};
+    NvPacket packet = {0};
+
+    if (ctx->in_error) {
+        return AVERROR_UNKNOWN;
+    }
+
+    if (frame) {
+        _nvframe.payload[0] = frame->data[0];
+        _nvframe.payload[1] = frame->data[1];
+        _nvframe.payload[2] = frame->data[2];
+
+        _nvframe.pts = frame->pts;
+
+        if (nvv4l2_encoder_put_frame(avctx, ctx, &_nvframe))
+            return AVERROR_UNKNOWN;
+    }
+
+    if (nvv4l2_encoder_get_packet(avctx, ctx, &packet))
+        return 0;
+
+    ff_alloc_packet2(avctx, pkt, packet.payload_size, packet.payload_size);
+
+    memcpy(pkt->data, packet.payload, packet.payload_size);
+    pkt->dts = pkt->pts = packet.pts;
+
+    if (packet.flags & AV_PKT_FLAG_KEY)
+        pkt->flags = AV_PKT_FLAG_KEY;
+
+    *got_packet = 1;
+
+    return 0;
+}
+
+static av_cold int nvv4l2enc_close(AVCodecContext *avctx)
+{
+    nvv4l2EncodeContext *nvv4l2_ctx = avctx->priv_data;
+    nvv4l2_encoder_close(avctx, nvv4l2_ctx->ctx);
+
+    return 0;
+}
+
+static const AVCodecDefault defaults[] = {
+    { "b",     "5M" },
+    { "qmin",  "-1" },
+    { "qmax",  "-1" },
+    { "qdiff", "-1" },
+    { "qblur", "-1" },
+    { "qcomp", "-1" },
+    { "g",     "50" },
+    { "bf",    "0" },
+    { "refs",  "0" },
+    { NULL },
+};
+
+#define OFFSET(x) offsetof(nvv4l2EncodeContext, x)
+#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+
+static const AVOption options_h264[] = {
+    { "num_capture_buffers", "Number of buffers in the capture context",
+        OFFSET(num_capture_buffers), AV_OPT_TYPE_INT, {.i64 = 10 }, 1, 32, VE },
+
+    { "profile",  "Set the encoding profile", OFFSET(profile), AV_OPT_TYPE_INT,
+        { .i64 = FF_PROFILE_H264_MAIN }, FF_PROFILE_H264_BASELINE,
+        FF_PROFILE_H264_HIGH_444_PREDICTIVE, VE, "profile" },
+#define PROFILE(name, value)  name, NULL, 0, AV_OPT_TYPE_CONST, \
+                              { .i64 = value }, 0, 0, VE, "profile"
+    { PROFILE("baseline", FF_PROFILE_H264_BASELINE) },
+    { PROFILE("main",     FF_PROFILE_H264_MAIN) },
+    { PROFILE("high",     FF_PROFILE_H264_HIGH) },
+    { PROFILE("high444",  FF_PROFILE_H264_HIGH_444_PREDICTIVE) },
+#undef PROFILE
+
+    { "level", "Profile Level", OFFSET(level), AV_OPT_TYPE_INT,
+        { .i64 = 51 }, 9, 51, VE, "level" },
+#define LEVEL(name, value) name, NULL, 0, AV_OPT_TYPE_CONST, \
+                           { .i64 = value }, 0, 0, VE, "level"
+    { LEVEL("1.0", 10) },
+    { LEVEL("1b",  9 ) },
+    { LEVEL("1.1", 11) },
+    { LEVEL("1.2", 12) },
+    { LEVEL("1.3", 13) },
+    { LEVEL("2.0", 20) },
+    { LEVEL("2.1", 21) },
+    { LEVEL("2.2", 22) },
+    { LEVEL("3.0", 30) },
+    { LEVEL("3.1", 31) },
+    { LEVEL("3.2", 32) },
+    { LEVEL("4.0", 40) },
+    { LEVEL("4.1", 41) },
+    { LEVEL("4.2", 42) },
+    { LEVEL("5.0", 50) },
+    { LEVEL("5.1", 51) },
+#undef LEVEL
+
+    { "lossless", "Enable lossless encoding", OFFSET(lossless), AV_OPT_TYPE_INT,
+        { .i64 = 0 }, 0, 1, VE, "lossless"},
+#define LOSSLESS(name, value)  name, NULL, 0, AV_OPT_TYPE_CONST, \
+                           { .i64 = value }, 0, 0, VE, "lossless"
+    { LOSSLESS("off", 0) },
+    { LOSSLESS("on",  1) },
+#undef LOSSLESS
+
+    { "rc",  "Override the preset rate-control",
+        OFFSET(rc), AV_OPT_TYPE_INT,   { .i64 = 1 }, 0, 1, VE, "rc" },
+    { "cbr", "Constant bitrate mode", 0, AV_OPT_TYPE_CONST,
+        { .i64 = 0  },  0, 0, VE, "rc" },
+    { "vbr", "Variable bitrate mode", 0, AV_OPT_TYPE_CONST,
+        { .i64 = 1  },  0, 0, VE, "rc" },
+
+    { "preset",    "Set the encoding preset", OFFSET(preset),
+        AV_OPT_TYPE_INT,   { .i64 = 3 }, 1, 4, VE, "preset" },
+    { "default",   "", 0, AV_OPT_TYPE_CONST, { .i64 = 3 }, 0, 0, VE, "preset" },
+    { "slow",      "", 0, AV_OPT_TYPE_CONST, { .i64 = 4 }, 0, 0, VE, "preset" },
+    { "medium",    "", 0, AV_OPT_TYPE_CONST, { .i64 = 3 }, 0, 0, VE, "preset" },
+    { "fast",      "", 0, AV_OPT_TYPE_CONST, { .i64 = 2 }, 0, 0, VE, "preset" },
+    { "ultrafast", "", 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, VE, "preset" },
+
+    { "2pass", "Enable Two-Pass CBR. (Forces CBR).",
+        OFFSET(twopass), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, 1, VE },
+#define TWOPASS(name, value)  name, NULL, 0, AV_OPT_TYPE_CONST, \
+                           { .i64 = value }, 0, 0, VE, "twopass"
+    { TWOPASS("off", 0) },
+    { TWOPASS("on",  1) },
+#undef TWOPASS
+    { NULL }
+};
+
+static const AVOption options_hevc[] = {
+    { "num_capture_buffers", "Number of buffers in the capture context",
+        OFFSET(num_capture_buffers), AV_OPT_TYPE_INT, {.i64 = 10 }, 1, 32, VE },
+
+    { "profile",  "Set the encoding profile", OFFSET(profile), AV_OPT_TYPE_INT,
+        { .i64 = FF_PROFILE_HEVC_MAIN }, FF_PROFILE_HEVC_MAIN,
+        FF_PROFILE_HEVC_MAIN_10, VE, "profile" },
+#define PROFILE(name, value)  name, NULL, 0, AV_OPT_TYPE_CONST, \
+                              { .i64 = value }, 0, 0, VE, "profile"
+    { PROFILE("main",   FF_PROFILE_HEVC_MAIN) },
+    { PROFILE("main10", FF_PROFILE_HEVC_MAIN_10) },
+#undef PROFILE
+
+    { "tier", "Set the encoding tier", OFFSET(tier), AV_OPT_TYPE_INT,
+        { .i64 = 0 }, 0, 1, VE, "tier"},
+#define TIER(name, value)  name, NULL, 0, AV_OPT_TYPE_CONST, \
+                           { .i64 = value }, 0, 0, VE, "tier"
+    { TIER("main", 0) },
+    { TIER("high", 1) },
+#undef TIER
+
+    { "level", "Profile Level", OFFSET(level), AV_OPT_TYPE_INT,
+        { .i64 = 186 }, 30, 186, VE, "level" },
+#define LEVEL(name, value) name, NULL, 0, AV_OPT_TYPE_CONST, \
+                           { .i64 = value }, 0, 0, VE, "level"
+    { LEVEL("1",    30) },
+    { LEVEL("2",    60) },
+    { LEVEL("2.1",  63) },
+    { LEVEL("3",    90) },
+    { LEVEL("3.1",  93) },
+    { LEVEL("4",   120) },
+    { LEVEL("4.1", 123) },
+    { LEVEL("5",   150) },
+    { LEVEL("5.1", 153) },
+    { LEVEL("5.2", 156) },
+    { LEVEL("6",   180) },
+    { LEVEL("6.1", 183) },
+    { LEVEL("6.2", 186) },
+#undef LEVEL
+
+    { "lossless", "Enable lossless encoding", OFFSET(lossless), AV_OPT_TYPE_INT,
+        { .i64 = 0 }, 0, 1, VE, "lossless"},
+#define LOSSLESS(name, value)  name, NULL, 0, AV_OPT_TYPE_CONST, \
+                           { .i64 = value }, 0, 0, VE, "lossless"
+    { LOSSLESS("off", 0) },
+    { LOSSLESS("on",  1) },
+#undef LOSSLESS
+
+    { "rc",  "Override the preset rate-control", OFFSET(rc),
+        AV_OPT_TYPE_INT,   { .i64 = 1 }, 0, 1, VE, "rc" },
+    { "cbr", "Constant bitrate mode", 0, AV_OPT_TYPE_CONST,
+        { .i64 = 0  },  0, 0, VE, "rc" },
+    { "vbr", "Variable bitrate mode", 0, AV_OPT_TYPE_CONST,
+        { .i64 = 1  },  0, 0, VE, "rc" },
+
+    { "preset",    "Set the encoding preset", OFFSET(preset),
+        AV_OPT_TYPE_INT,   { .i64 = 3 }, 3, 4, VE, "preset" },
+    { "default",   "", 0, AV_OPT_TYPE_CONST, { .i64 = 3 }, 0, 0, VE, "preset" },
+    { "slow",      "", 0, AV_OPT_TYPE_CONST, { .i64 = 4 }, 0, 0, VE, "preset" },
+    { "medium",    "", 0, AV_OPT_TYPE_CONST, { .i64 = 3 }, 0, 0, VE, "preset" },
+    { "fast",      "", 0, AV_OPT_TYPE_CONST, { .i64 = 2 }, 0, 0, VE, "preset" },
+    { "ultrafast", "", 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, VE, "preset" },
+
+    { "2pass", "Enable Two-Pass CBR. (Forces CBR).",
+        OFFSET(twopass), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, 1, VE },
+#define TWOPASS(name, value)  name, NULL, 0, AV_OPT_TYPE_CONST, \
+                           { .i64 = value }, 0, 0, VE, "twopass"
+    { TWOPASS("off", 0) },
+    { TWOPASS("on",  1) },
+#undef TWOPASS
+    { NULL }
+};
+
+#define NVV4L2_ENC_CLASS(NAME)                         \
+    static const AVClass nvv4l2_##NAME##_enc_class = { \
+        .class_name = "nvv4l2_" #NAME "_enc",          \
+        .item_name  = av_default_item_name,            \
+        .option     = options_##NAME,                  \
+        .version    = LIBAVUTIL_VERSION_INT,           \
+    };
+
+#define NVV4L2_ENC(NAME, ID)                                                          \
+    NVV4L2_ENC_CLASS(NAME)                                                            \
+    AVCodec ff_##NAME##_nvv4l2_encoder = {                                            \
+        .name           = #NAME "_nvv4l2" ,                                           \
+        .long_name      = NULL_IF_CONFIG_SMALL(#NAME " NVV4L2 HW encoder for Tegra"), \
+        .type           = AVMEDIA_TYPE_VIDEO,                                         \
+        .id             = ID,                                                         \
+        .priv_data_size = sizeof(nvv4l2EncodeContext),                                \
+        .init           = nvv4l2enc_init,                                             \
+        .close          = nvv4l2enc_close,                                            \
+        .encode2        = nvv4l2enc_encode,                                           \
+        .priv_class     = &nvv4l2_##NAME##_enc_class,                                 \
+        .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE,                 \
+        .defaults       = defaults,                                                   \
+        .wrapper_name   = "nvv4l2",                                                   \
+        .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,          \
+                                                         AV_PIX_FMT_YUV444P,          \
+                                                         AV_PIX_FMT_NV12,             \
+                                                         AV_PIX_FMT_P010,             \
+                                                         AV_PIX_FMT_YUV420P10,        \
+                                                         AV_PIX_FMT_NONE },           \
+    };
+
+NVV4L2_ENC(h264, AV_CODEC_ID_H264);
+NVV4L2_ENC(hevc, AV_CODEC_ID_HEVC);
diff --git a/libavcodec/nvv4l2_ext_utils.h b/libavcodec/nvv4l2_ext_utils.h
new file mode 100644
index 0000000000..b9aa30f195
--- /dev/null
+++ b/libavcodec/nvv4l2_ext_utils.h
@@ -0,0 +1,2475 @@
+/*
+ * Copyright (c) 2016-2022, NVIDIA CORPORATION.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *  3. The names of its contributors may not be used to endorse or promote
+ *     products derived from this software without specific prior written
+ *     permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* This file contains amendments to the V4L2 headers made after the
+ * supported kernel version and NVIDIA extensions.
+ */
+
+#ifndef __NVV4L2_EXT_UTILS_H__
+#define __NVV4L2_EXT_UTILS_H__
+
+#include <errno.h>
+
+/**
+ * @file
+ * <b>NVIDIA V4L2 API Extensions</b>
+ *
+ * @b Description: This file declares NVIDIA V4L2 extensions,
+ * controls and structures.
+ */
+
+/**
+ *
+ * @defgroup ee_extensions_group V4L2 NV Extensions API
+ *
+ * This file declares NVIDIA V4L2 extensions, controls, and structures.
+ *
+ */
+/**
+ * Defines V4L2 pixel format for DIVX.
+ */
+#define V4L2_PIX_FMT_DIVX4     v4l2_fourcc('D', 'V', 'X', '4')
+
+#define V4L2_PIX_FMT_DIVX5     v4l2_fourcc('D', 'V', 'X', '5')
+/**
+ * Defines V4L2 pixel format for H.265.
+ */
+#define V4L2_PIX_FMT_H265     v4l2_fourcc('H', '2', '6', '5')
+
+/**
+ * Defines the V4L2 pixel format for VP9.
+ */
+#define V4L2_PIX_FMT_VP9      v4l2_fourcc('V', 'P', '9', '0')
+
+/**
+ * Defines the V4L2 pixel format for representing single plane 10-bit Y/CbCr 4:2:0 decoder data.
+ */
+#define V4L2_PIX_FMT_P010    v4l2_fourcc('P', '0', '1', '0') /* Y/CbCr 4:2:0, 10 bits per channel */
+
+/**
+ * Defines the V4L2 pixel format for representing semi-planar 10-bit Y/CbCr 4:2:0 decoder data.
+ */
+#define V4L2_PIX_FMT_P010M   v4l2_fourcc('P', 'M', '1', '0') /* Y/CbCr 4:2:0, 10 bits per channel */
+
+/**
+ * Defines the V4L2 pixel format for representing single plane 12-bit Y/CbCr 4:2:0 decoder data.
+ */
+#define V4L2_PIX_FMT_P012    v4l2_fourcc('P', '0', '1', '2') /* Y/CbCr 4:2:0, 12 bits per channel */
+
+/**
+ * Defines the V4L2 pixel format for representing semi-planar 12-bit Y/CbCr 4:2:0 decoder data.
+ */
+#define V4L2_PIX_FMT_P012M   v4l2_fourcc('P', 'M', '1', '2') /* Y/CbCr 4:2:0, 12 bits per channel */
+
+/**
+ * Defines the V4L2 pixel format for representing semi-planar 8-bit Y/CbCr 4:4:4 decoder data.
+ */
+#define V4L2_PIX_FMT_NV24M   v4l2_fourcc('N', 'M', '2', '4') /* Y/CbCr 4:4:4, 8 bits per channel */
+
+/**
+ * Defines the V4L2 pixel format for representing semi-planar 10-bit Y/CbCr 4:4:4 decoder data.
+ */
+#define V4L2_PIX_FMT_NV24_10LE   v4l2_fourcc('N', 'V', '1', '0') /* Y/CbCr 4:4:4, 10 bits per channel */
+
+
+/** @cond UNUSED */
+/* >> The declarations from here to the next endcond statement are not
+ * >> currently implemented. DO NOT USE. */
+
+#define V4L2_PIX_FMT_YUV422RM v4l2_fourcc('4', '2', 'R', 'M')
+
+
+#define V4L2_PIX_FMT_H264_SLICE v4l2_fourcc('S', '2', '6', '4') /** H264 parsed slices. */
+#define V4L2_PIX_FMT_VP8_FRAME v4l2_fourcc('V', 'P', '8', 'F') /** VP8 parsed frames. */
+
+#define V4L2_CTRL_FLAG_CAN_STORE    0x0200
+
+/** @endcond */
+
+/**
+ * Defines the V4L2 event type for decoder resolution event change.
+ */
+#define V4L2_EVENT_RESOLUTION_CHANGE        5
+
+/** @cond UNUSED */
+/* >> The declarations from here to the next endcond statement are not
+ * >> currently implemented. DO NOT USE. */
+
+/*---------------Below are changes from the v4l2-controls.h----------------------*/
+
+#define V4L2_CID_MPEG_VIDEO_H264_SPS        (V4L2_CID_MPEG_BASE+383)
+#define V4L2_CID_MPEG_VIDEO_H264_PPS        (V4L2_CID_MPEG_BASE+384)
+#define V4L2_CID_MPEG_VIDEO_H264_SCALING_MATRIX (V4L2_CID_MPEG_BASE+385)
+#define V4L2_CID_MPEG_VIDEO_H264_SLICE_PARAM    (V4L2_CID_MPEG_BASE+386)
+#define V4L2_CID_MPEG_VIDEO_H264_DECODE_PARAM   (V4L2_CID_MPEG_BASE+387)
+
+#define V4L2_CID_MPEG_VIDEO_VP8_FRAME_HDR       (V4L2_CID_MPEG_BASE+512)
+
+/** @endcond */
+
+/**
+ * Defines the control ID to set the H.265 encoder profile.
+ *
+ * A v4l2_mpeg_video_h265_profile must be passed.
+ */
+#define V4L2_CID_MPEG_VIDEO_H265_PROFILE        (V4L2_CID_MPEG_BASE+513)
+
+/**
+ * Defines the possible profiles for H.265 encoder.
+ */
+enum v4l2_mpeg_video_h265_profile {
+    /** H.265 Main profile. */
+    V4L2_MPEG_VIDEO_H265_PROFILE_MAIN = 0,
+    /** H.265 Main10 profile. */
+    V4L2_MPEG_VIDEO_H265_PROFILE_MAIN10 = 1,
+    /** H.265 MainStillPicture profile. */
+    V4L2_MPEG_VIDEO_H265_PROFILE_MAINSTILLPICTURE = 2,
+};
+
+/**
+ * Defines the control ID to set the encoder IDR frame interval.
+ * Must be used with \c VIDIOC_S_EXT_CTRLS IOCTL.
+ */
+#define V4L2_CID_MPEG_VIDEO_IDR_INTERVAL        (V4L2_CID_MPEG_BASE+514)
+
+/** @cond UNUSED */
+/* >> The declarations from here to the next endcond statement are not
+ * >> currently implemented. DO NOT USE. */
+
+/* Complex controls */
+
+#define V4L2_H264_SPS_CONSTRAINT_SET0_FLAG          0x01
+#define V4L2_H264_SPS_CONSTRAINT_SET1_FLAG          0x02
+#define V4L2_H264_SPS_CONSTRAINT_SET2_FLAG          0x04
+#define V4L2_H264_SPS_CONSTRAINT_SET3_FLAG          0x08
+#define V4L2_H264_SPS_CONSTRAINT_SET4_FLAG          0x10
+#define V4L2_H264_SPS_CONSTRAINT_SET5_FLAG          0x20
+
+#define V4L2_H264_SPS_FLAG_SEPARATE_COLOUR_PLANE        0x01
+#define V4L2_H264_SPS_FLAG_QPPRIME_Y_ZERO_TRANSFORM_BYPASS  0x02
+#define V4L2_H264_SPS_FLAG_DELTA_PIC_ORDER_ALWAYS_ZERO      0x04
+#define V4L2_H264_SPS_FLAG_GAPS_IN_FRAME_NUM_VALUE_ALLOWED  0x08
+#define V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY           0x10
+#define V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD      0x20
+#define V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE         0x40
+/* struct v4l2_ctrl_h264_sps {
+    __u8 profile_idc;
+    __u8 constraint_set_flags;
+    __u8 level_idc;
+    __u8 seq_parameter_set_id;
+    __u8 chroma_format_idc;
+    __u8 bit_depth_luma_minus8;
+    __u8 bit_depth_chroma_minus8;
+    __u8 log2_max_frame_num_minus4;
+    __u8 pic_order_cnt_type;
+    __u8 log2_max_pic_order_cnt_lsb_minus4;
+    __s32 offset_for_non_ref_pic;
+    __s32 offset_for_top_to_bottom_field;
+    __u8 num_ref_frames_in_pic_order_cnt_cycle;
+    __s32 offset_for_ref_frame[255];
+    __u8 max_num_ref_frames;
+    __u16 pic_width_in_mbs_minus1;
+    __u16 pic_height_in_map_units_minus1;
+    __u8 flags;
+}; */
+
+#define V4L2_H264_PPS_FLAG_ENTROPY_CODING_MODE              0x0001
+#define V4L2_H264_PPS_FLAG_BOTTOM_FIELD_PIC_ORDER_IN_FRAME_PRESENT  0x0002
+#define V4L2_H264_PPS_FLAG_WEIGHTED_PRED                0x0004
+#define V4L2_H264_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT        0x0008
+#define V4L2_H264_PPS_FLAG_CONSTRAINED_INTRA_PRED           0x0010
+#define V4L2_H264_PPS_FLAG_REDUNDANT_PIC_CNT_PRESENT            0x0020
+#define V4L2_H264_PPS_FLAG_TRANSFORM_8X8_MODE               0x0040
+#define V4L2_H264_PPS_FLAG_PIC_SCALING_MATRIX_PRESENT           0x0080
+/* struct v4l2_ctrl_h264_pps {
+    __u8 pic_parameter_set_id;
+    __u8 seq_parameter_set_id;
+    __u8 num_slice_groups_minus1;
+    __u8 num_ref_idx_l0_default_active_minus1;
+    __u8 num_ref_idx_l1_default_active_minus1;
+    __u8 weighted_bipred_idc;
+    __s8 pic_init_qp_minus26;
+    __s8 pic_init_qs_minus26;
+    __s8 chroma_qp_index_offset;
+    __s8 second_chroma_qp_index_offset;
+    __u8 flags;
+}; */
+
+/* struct v4l2_ctrl_h264_scaling_matrix {
+    __u8 scaling_list_4x4[6][16];
+    __u8 scaling_list_8x8[6][64];
+}; */
+
+/* struct v4l2_h264_weight_factors {
+    __s8 luma_weight[32];
+    __s8 luma_offset[32];
+    __s8 chroma_weight[32][2];
+    __s8 chroma_offset[32][2];
+}; */
+
+struct v4l2_h264_pred_weight_table {
+    __u8 luma_log2_weight_denom;
+    __u8 chroma_log2_weight_denom;
+    struct v4l2_h264_weight_factors weight_factors[2];
+};
+
+#define V4L2_SLICE_FLAG_FIELD_PIC       0x01
+#define V4L2_SLICE_FLAG_BOTTOM_FIELD        0x02
+#define V4L2_SLICE_FLAG_DIRECT_SPATIAL_MV_PRED  0x04
+#define V4L2_SLICE_FLAG_SP_FOR_SWITCH       0x08
+struct v4l2_ctrl_h264_slice_param {
+    /** Holds the size in bytes, including the header. */
+    __u32 size;
+    /** Holds the offset in bits to slice_data() from the beginning of this slice. */
+    __u32 header_bit_size;
+
+    __u16 first_mb_in_slice;
+    __u8 slice_type;
+    __u8 pic_parameter_set_id;
+    __u8 colour_plane_id;
+    __u16 frame_num;
+    __u16 idr_pic_id;
+    __u16 pic_order_cnt_lsb;
+    __s32 delta_pic_order_cnt_bottom;
+    __s32 delta_pic_order_cnt0;
+    __s32 delta_pic_order_cnt1;
+    __u8 redundant_pic_cnt;
+
+    struct v4l2_h264_pred_weight_table pred_weight_table;
+    /* Size in bits of dec_ref_pic_marking() syntax element. */
+    __u32 dec_ref_pic_marking_bit_size;
+    /* Size in bits of pic order count syntax. */
+    __u32 pic_order_cnt_bit_size;
+
+    __u8 cabac_init_idc;
+    __s8 slice_qp_delta;
+    __s8 slice_qs_delta;
+    __u8 disable_deblocking_filter_idc;
+    __s8 slice_alpha_c0_offset_div2;
+    __s8 slice_beta_offset_div2;
+    __u32 slice_group_change_cycle;
+
+    __u8 num_ref_idx_l0_active_minus1;
+    __u8 num_ref_idx_l1_active_minus1;
+    /*  Entries on each list are indices
+     *  into v4l2_ctrl_h264_decode_param.dpb[]. */
+    __u8 ref_pic_list0[32];
+    __u8 ref_pic_list1[32];
+
+    __u8 flags;
+};
+
+/** Defines whether the v4l2_h264_dpb_entry structure is used.
+If not set, this entry is unused for reference. */
+#define V4L2_H264_DPB_ENTRY_FLAG_ACTIVE     0x01
+#define V4L2_H264_DPB_ENTRY_FLAG_LONG_TERM  0x02
+/* struct v4l2_h264_dpb_entry { */
+/*    __u32 buf_index; /**< v4l2_buffer index. */
+/*    __u16 frame_num;
+    __u16 pic_num; */
+    /** @note `v4l2_buffer.field` specifies this field. */
+/*    __s32 top_field_order_cnt;
+    __s32 bottom_field_order_cnt; */
+/*    __u8 flags; /* V4L2_H264_DPB_ENTRY_FLAG_* */
+/* }; */
+
+struct v4l2_ctrl_h264_decode_param {
+    __u32 num_slices;
+    __u8 idr_pic_flag;
+    __u8 nal_ref_idc;
+    __s32 top_field_order_cnt;
+    __s32 bottom_field_order_cnt;
+    __u8 ref_pic_list_p0[32];
+    __u8 ref_pic_list_b0[32];
+    __u8 ref_pic_list_b1[32];
+    struct v4l2_h264_dpb_entry dpb[16];
+};
+
+#define V4L2_VP8_SEGMNT_HDR_FLAG_ENABLED              0x01
+#define V4L2_VP8_SEGMNT_HDR_FLAG_UPDATE_MAP           0x02
+#define V4L2_VP8_SEGMNT_HDR_FLAG_UPDATE_FEATURE_DATA  0x04
+struct v4l2_vp8_sgmnt_hdr {
+    __u8 segment_feature_mode;
+
+    __s8 quant_update[4];
+    __s8 lf_update[4];
+    __u8 segment_probs[3];
+
+    __u8 flags;
+};
+
+#define V4L2_VP8_LF_HDR_ADJ_ENABLE  0x01
+#define V4L2_VP8_LF_HDR_DELTA_UPDATE    0x02
+struct v4l2_vp8_loopfilter_hdr {
+    __u8 type;
+    __u8 level;
+    __u8 sharpness_level;
+    __s8 ref_frm_delta_magnitude[4];
+    __s8 mb_mode_delta_magnitude[4];
+
+    __u8 flags;
+};
+
+struct v4l2_vp8_quantization_hdr {
+    __u8 y_ac_qi;
+    __s8 y_dc_delta;
+    __s8 y2_dc_delta;
+    __s8 y2_ac_delta;
+    __s8 uv_dc_delta;
+    __s8 uv_ac_delta;
+    __u16 dequant_factors[4][3][2];
+};
+
+struct v4l2_vp8_entropy_hdr {
+    __u8 coeff_probs[4][8][3][11];
+    __u8 y_mode_probs[4];
+    __u8 uv_mode_probs[3];
+    __u8 mv_probs[2][19];
+};
+
+#define V4L2_VP8_FRAME_HDR_FLAG_EXPERIMENTAL        0x01
+#define V4L2_VP8_FRAME_HDR_FLAG_SHOW_FRAME      0x02
+#define V4L2_VP8_FRAME_HDR_FLAG_MB_NO_SKIP_COEFF    0x04
+struct v4l2_ctrl_vp8_frame_hdr {
+    /** 0: keyframe, 1: not a keyframe. */
+    __u8 key_frame;
+    __u8 version;
+
+    /** Populated also if not a key frame. */
+    __u16 width;
+    __u8 horizontal_scale;
+    __u16 height;
+    __u8 vertical_scale;
+
+    struct v4l2_vp8_sgmnt_hdr sgmnt_hdr;
+    struct v4l2_vp8_loopfilter_hdr lf_hdr;
+    struct v4l2_vp8_quantization_hdr quant_hdr;
+    struct v4l2_vp8_entropy_hdr entropy_hdr;
+
+    __u8 sign_bias_golden;
+    __u8 sign_bias_alternate;
+
+    __u8 prob_skip_false;
+    __u8 prob_intra;
+    __u8 prob_last;
+    __u8 prob_gf;
+
+    __u32 first_part_size;
+    /**
+     * Holds the offset in bits of the MB data in the first partition,
+     * i.e. bit offset starting from first_part_offset.
+     */
+    __u32 first_part_offset;
+    __u32 macroblock_bit_offset;
+
+    __u8 num_dct_parts;
+    __u32 dct_part_sizes[8];
+
+    __u8 bool_dec_range;
+    __u8 bool_dec_value;
+    __u8 bool_dec_count;
+
+    /** Holds the v4l2_buffer index of the last reference frame. */
+    __u32 last_frame;
+     /** Holds the v4l2_buffer index of the golden reference frame. */
+   __u32 golden_frame;
+    /** Holds the v4l2_buffer index of the alt reference frame. */
+    __u32 alt_frame;
+
+    __u8 flags;
+};
+
+/** @endcond */
+
+/*---------------Add below NVIDIA specific extensions ----------------------*/
+
+/**
+ * @defgroup V4L2Dec V4L2 Video Decoder
+ *
+ * @brief NVIDIA V4L2 Video Decoder Description and Extensions
+ *
+ * The video decoder device node is
+ *
+ *     /dev/nvhost-nvdec
+ *
+ * ### Supported Pixel Formats
+ * OUTPUT PLANE       | CAPTURE PLANE
+ * :----------------: | :----------------:
+ * V4L2_PIX_FMT_H264  | V4L2_PIX_FMT_NV12M
+ * V4L2_PIX_FMT_H265  | V4L2_PIX_FMT_NV12M
+ *
+ * ### Supported Memory Types
+ * MEMORY               | OUTPUT PLANE | CAPTURE PLANE
+ * :------------------: | :----------: | :-----------:
+ * V4L2_MEMORY_MMAP     | Y            | Y
+ * V4L2_MEMORY_DMABUF   | N            | Y
+ * V4L2_MEMORY_USERPTR  | Y            | N
+ *
+ * ### Supported Controls
+ * - #V4L2_CID_MPEG_VIDEO_DISABLE_COMPLETE_FRAME_INPUT
+ * - #V4L2_CID_MPEG_VIDEO_DISABLE_DPB
+ * - #V4L2_CID_MPEG_VIDEO_ERROR_REPORTING
+ * - #V4L2_CID_MPEG_VIDEO_SKIP_FRAMES
+ * - V4L2_CID_MIN_BUFFERS_FOR_CAPTURE (Get the minimum buffers to be allocated on capture plane.
+ * Read only. Valid after #V4L2_EVENT_RESOLUTION_CHANGE)
+ * - #V4L2_CID_MPEG_VIDEODEC_INPUT_METADATA
+ * - #V4L2_CID_MPEG_VIDEODEC_METADATA
+ * - #V4L2_CID_MPEG_VIDEO_BUF_API_TYPE
+ * - #V4L2_CID_MPEG_VIDEO_CUDA_MEM_TYPE
+ * - #V4L2_CID_MPEG_VIDEO_CUDA_GPU_ID
+ * - #V4L2_CID_MPEG_VIDEODEC_DROP_FRAME_INTERVAL
+ *
+ * ### Supported Events
+ * Event                         | Purpose
+ * ----------------------------- | :----------------------------:
+ * #V4L2_EVENT_RESOLUTION_CHANGE | Resolution of the stream has changed.
+ *
+ * ### Handling Resolution Change Events
+ * When the decoder generates a \c V4L2_EVENT_RESOLUTION_CHANGE event, the
+ * application calls \c STREAMOFF on the capture plane to tell the decoder to
+ * deallocate the current buffers by calling REQBUF with count zero, get
+ * the new capture plane format, and then proceed with setting up the buffers
+ * for the capture plane.
+ *
+ * In case of decoder, the buffer format might differ from the display resolution.
+ * The application must use \c VIDIOC_G_CROP to get the display resolution.
+ *
+ * ### EOS Handling
+ * The following sequence must be followed for sending EOS and recieving EOS
+ * from the decoder.
+ * -# Send EOS to decoder by queueing on the output plane a buffer with
+ * bytesused = 0 for the 0th plane (`v4l2_buffer.m.planes[0].bytesused = 0`).
+ * -# Dequeues buffers on the output plane until it gets a buffer with bytesused = 0
+ * for the 0th plane (`v4l2_buffer.m.planes[0].bytesused == 0`)
+ * -# Dequeues buffers on the capture plane until it gets a buffer with bytesused = 0
+ * for the 0th plane.
+ *
+ * ### Decoder Input Frame Metadata
+ * Decoder supports reporting stream header parsing error info as input frame metadata.
+ * See \c V4L2_CID_MPEG_VIDEO_ERROR_REPORTING, \c V4L2_CID_MPEG_VIDEODEC_INPUT_METADATA
+ * and \c v4l2_ctrl_video_metadata for more information.
+ *
+ * ### Decoder Output Frame Metadata
+ * Decoder supports reporting frame related metadata, including error reports and
+ * DPB info. See \c V4L2_CID_MPEG_VIDEO_ERROR_REPORTING, \c V4L2_CID_MPEG_VIDEODEC_METADATA
+ * and \c v4l2_ctrl_video_metadata for more information.
+ *
+ * @note Currently, V4L2 plugins do not support odd resolution.
+ * @{
+ * @ingroup ee_extensions_group
+ */
+
+/**
+ * Defines the Control ID to indicate to the decoder that the input
+ * buffers do not contain complete buffers.
+ *
+ * @note This control must be set in case of frames containing multiple slices
+ * when the input buffers do not contain all the slices of the frame.
+ *
+ * A boolean value must be supplied with this control.
+ *
+ */
+#define V4L2_CID_MPEG_VIDEO_DISABLE_COMPLETE_FRAME_INPUT (V4L2_CID_MPEG_BASE+515)
+
+/**
+ * Defines the Control ID to disable decoder DPB management.
+ *
+ * @note This only works for streams having a single reference frame.
+ *
+ * A boolean value must be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_DISABLE_DPB (V4L2_CID_MPEG_BASE+516)
+
+/**
+ * Defines the Control ID to enable decoder error and metadata reporting.
+ *
+ * A boolean value must be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_ERROR_REPORTING (V4L2_CID_MPEG_BASE+517)
+
+/**
+ * Defines the Control ID to set the skip frames property of the decoder.
+ *
+ * Decoder must be configured to skip certain types of frames. One
+ * \c v4l2_skip_frames_type must be passed.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ * This control ID is supported only for H264.
+ */
+#define V4L2_CID_MPEG_VIDEO_SKIP_FRAMES (V4L2_CID_MPEG_BASE+518)
+
+/**
+ * Defines the Control ID to get the decoder output metadata.
+ *
+ * @note Metadata reporting must be enabled using
+ * #V4L2_CID_MPEG_VIDEO_ERROR_REPORTING IOCTL for this.
+ *
+ * A pointer to a valid \c v4l2_ctrl_video_metadata structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be read after dequeueing a buffer successfully from
+ * the capture plane. The values in the structure are valid until the buffer is queued
+ * again.
+ */
+#define V4L2_CID_MPEG_VIDEODEC_METADATA (V4L2_CID_MPEG_BASE+519)
+
+/**
+ * Defines the Control ID to get the decoder input header error metadata.
+ *
+ * @note Metadata reporting must be enabled using
+ * #V4L2_CID_MPEG_VIDEO_ERROR_REPORTING IOCTL for this.
+ *
+ * A pointer to a valid \c v4l2_ctrl_video_metadata structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be read after dequeueing a buffer successfully from
+ * the output plane. The values in the structure are valid until the buffer is queued
+ * again.
+ */
+#define V4L2_CID_MPEG_VIDEODEC_INPUT_METADATA (V4L2_CID_MPEG_BASE+520)
+
+/**
+ * Defines the Control ID to check if display data is present.
+ *
+ * This control returns true if HDR metadata is present in the stream.
+ *
+ */
+#define V4L2_CID_VIDEODEC_DISPLAYDATA_PRESENT (V4L2_CID_MPEG_BASE+521)
+
+/**
+ * Defines the Control ID to get display data if V4L2_CID_VIDEODEC_DISPLAYDATA_PRESENT returns true.
+ *
+ * This control returns display data such as display_primaries, white_point and
+ * display_parameter_luminance required for display module.
+ *
+ */
+#define V4L2_CID_VIDEODEC_HDR_MASTERING_DISPLAY_DATA (V4L2_CID_MPEG_BASE+522)
+
+/**
+ * Defines the Control ID to get Sample Aspect Ratio width for decoding.
+ *
+ * This control returns unsigned integer of Sample Aspect Ratio width.
+ *
+ * @attention This control must be set after receiving V4L2_EVENT_RESOLUTION_CHANGE.
+ *
+ */
+#define V4L2_CID_MPEG_VIDEODEC_SAR_WIDTH (V4L2_CID_MPEG_BASE+569)
+
+/**
+ * Defines the Control ID to get Sample Aspect Ratio height for decoding.
+ *
+ * This control returns unsigned integer of Sample Aspect Ratio height.
+ *
+ * @attention This control must be set after receiving V4L2_EVENT_RESOLUTION_CHANGE.
+ *
+ */
+#define V4L2_CID_MPEG_VIDEODEC_SAR_HEIGHT (V4L2_CID_MPEG_BASE+570)
+
+/** @} */
+
+/**
+ * @defgroup V4L2Conv V4L2 Video Converter
+ *
+ * @brief NVIDIA V4L2 Video Converter Description and Extensions
+ *
+ * Use the video converter for color space conversion, scaling, and
+ * conversion between hardware buffer memory (\c V4L2_MEMORY_MMAP/\c
+ * V4L2_MEMORY_DMABUF), software buffer memory (\c V4L2_MEMORY_USERPTR), and
+ * other operations such as cropping, flipping/rotating, and
+ * temporal noise reduction (TNR).
+ * The video converter device node is \c "/dev/nvhost-vic".
+ *
+ * ### Supported Pixelformats
+ *  PIXEL FORMAT           | PIXEL FORMAT
+ * :---------------------: | :--------------:
+ * V4L2_PIX_FMT_YUV444M    | V4L2_PIX_FMT_YVU422M
+ * V4L2_PIX_FMT_YUV420M    | V4L2_PIX_FMT_YVU420M
+ * V4L2_PIX_FMT_NV12M      | V4L2_PIX_FMT_GREY
+ * V4L2_PIX_FMT_YUYV       | V4L2_PIX_FMT_YVYU
+ * V4L2_PIX_FMT_UYVY       | V4L2_PIX_FMT_VYUY
+ * V4L2_PIX_FMT_ABGR32     | V4L2_PIX_FMT_XBGR32
+ *
+ * ### Supported Pixel Formats for TNR
+ *  PIXEL FORMAT           | PIXEL FORMAT
+ * :---------------------: | :--------------:
+ * V4L2_PIX_FMT_YUV420M    | V4L2_PIX_FMT_NV12M
+ * V4L2_PIX_FMT_UYVY       | V4L2_PIX_FMT_YUYV
+ *
+ * ### Supported Memory Types
+ * MEMORY               | OUTPUT PLANE | CAPTURE PLANE
+ * :------------------: | :----------: | :-----------:
+ * V4L2_MEMORY_MMAP     | Y            | Y
+ * V4L2_MEMORY_DMABUF   | Y            | Y
+ * V4L2_MEMORY_USERPTR  | Y            | Y
+ *
+ * ### Supported Controls
+ * - #V4L2_CID_VIDEO_CONVERT_OUTPUT_PLANE_LAYOUT
+ * - #V4L2_CID_VIDEO_CONVERT_CAPTURE_PLANE_LAYOUT
+ * - #V4L2_CID_VIDEO_CONVERT_FLIP_METHOD
+ * - #V4L2_CID_VIDEO_CONVERT_INTERPOLATION_METHOD
+ * - #V4L2_CID_VIDEO_CONVERT_TNR_ALGORITHM
+ * - #V4L2_CID_VIDEO_CONVERT_YUV_RESCALE_METHOD
+ *
+ * ### Cropping
+ * Video converter supports cropping using \c VIDIOC_S_SELECTION IOCTL with type
+ * \c V4L2_BUF_TYPE_VIDEO_CAPTURE and target \c V4L2_SEL_TGT_CROP. This must
+ * be set before requesting buffers on either plane.
+ *
+ * ### EOS Handling
+ * The following sequence must be followed for sending EOS and recieving EOS
+ * from the converter.
+ * -# Send EOS to converter by queueing on the output plane a buffer with
+ * bytesused = 0 for the 0th plane (`v4l2_buffer.m.planes[0].bytesused = 0`).
+ * -# Dequeues buffers on the capture plane until it gets a buffer with bytesused = 0
+ * for the 0th plane.
+ *
+ * @note Currently, V4L2 plugins do not support odd resolution.
+ * @{
+ * @ingroup ee_extensions_group
+ */
+
+/**
+ * Defines the Control ID to set converter output plane buffer layout.
+ *
+ * A value of type \c v4l2_nv_buffer_layout must be supplied with this control.
+ *
+ * @attention This control must be set before requesting buffers on the output plane.
+ */
+#define V4L2_CID_VIDEO_CONVERT_OUTPUT_PLANE_LAYOUT   (V4L2_CID_MPEG_BASE+523)
+
+/**
+ * Defines the Control ID to set converter capture plane buffer layout.
+ *
+ * A value of type \c v4l2_nv_buffer_layout must be supplied with this control.
+ *
+ * @attention This control must be set before requesting buffers on the capture plane.
+ */
+#define V4L2_CID_VIDEO_CONVERT_CAPTURE_PLANE_LAYOUT  (V4L2_CID_MPEG_BASE+524)
+
+/**
+ * Defines the Control ID to set the converter flip/rotation method.
+ *
+ * A value of type \c v4l2_flip_method must be supplied with this control.
+ *
+ * @attention This control must be set before requesting buffers on either plane.
+ */
+#define V4L2_CID_VIDEO_CONVERT_FLIP_METHOD           (V4L2_CID_MPEG_BASE+525)
+
+/**
+ * Defines the Control ID to set the converter interpolation method.
+ *
+ * A value of type \c v4l2_interpolation_method must be supplied with this control.
+ *
+ * @attention This control must be set before requesting buffers on either plane.
+ */
+#define V4L2_CID_VIDEO_CONVERT_INTERPOLATION_METHOD  (V4L2_CID_MPEG_BASE+526)
+
+/**
+ * Defines the Control ID to set the converter Temporal Noise Reduction (TNR) algorithm.
+ *
+ * A value of type \c v4l2_tnr_algorithm must be supplied with this control.
+ *
+ * @attention This control must be set before requesting buffers on either plane.
+ * @attention TNR algorithms are not supported with YUV422 and YUV444 capture
+ *            plane formats.
+ */
+#define V4L2_CID_VIDEO_CONVERT_TNR_ALGORITHM         (V4L2_CID_MPEG_BASE+527)
+/** @} */
+
+/**
+ * @defgroup V4L2Enc V4L2 Video Encoder
+ *
+ * @brief NVIDIA V4L2 Video Encoder Description and Extensions
+ *
+ * The video encoder device node is \c "/dev/nvhost-msenc".
+ *
+ * ### Supported Pixelformats
+ * OUTPUT PLANE            | CAPTURE PLANE
+ * :---------------------: | :--------------
+ * V4L2_PIX_FMT_YUV420M    | V4L2_PIX_FMT_H264
+ *           -             | V4L2_PIX_FMT_H265
+ *
+ * ### Supported Memory Types
+ * MEMORY               | OUTPUT PLANE | CAPTURE PLANE
+ * :------------------: | :----------: | :-----------:
+ * V4L2_MEMORY_MMAP     | Y            | Y
+ * V4L2_MEMORY_DMABUF   | Y            | N
+ * V4L2_MEMORY_USERPTR  | N            | N
+ * \attention For the video encoder, it is necessary that the capture plane
+ *  format be set before the output plane format and only then request buffers on
+ *  any of the planes.
+ *
+ * ### Supported Controls
+ * The following sections describe the supported controls.
+ *
+ * #### Controls From the Open Source V4L2-Controls Header
+ * Control ID                       | Purpose              | Runtime Configurable
+ * -------------------------------- | -------------------- | :------------------:
+ * V4L2_CID_MPEG_VIDEO_BITRATE      | Bitrate              | Y
+ * V4L2_CID_MPEG_VIDEO_H264_PROFILE | H.264 Encode Profile | N
+ * V4L2_CID_MPEG_VIDEO_BITRATE_MODE | Rate Control Mode    | N
+ * V4L2_CID_MPEG_VIDEO_GOP_SIZE     | I-frame Interval     | N
+ * V4L2_CID_MPEG_VIDEO_H264_LEVEL   | Encode Level         | N
+ * V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE | Force I-frame on one of queued output plane buffer | Y
+ *
+ * All non-runtime configurable options must be set after setting formats on
+ * both the planes and before requesting buffers on either plane.
+ *
+ * The runtime configurable parameters can be called anytime after setting
+ * formats on both the planes.
+ *
+ * #### NVIDIA-Specific Controls
+ * - #V4L2_CID_MPEG_VIDEO_H265_PROFILE
+ * - #V4L2_CID_MPEG_VIDEO_IDR_INTERVAL
+ * - #V4L2_CID_MPEG_VIDEOENC_TEMPORAL_TRADEOFF_LEVEL
+ * - #V4L2_CID_MPEG_VIDEOENC_SLICE_LENGTH_PARAM
+ * - #V4L2_CID_MPEG_VIDEOENC_ROI_PARAMS
+ * - #V4L2_CID_MPEG_VIDEOENC_VIRTUALBUFFER_SIZE
+ * - #V4L2_CID_MPEG_VIDEOENC_NUM_REFERENCE_FRAMES
+ * - #V4L2_CID_MPEG_VIDEOENC_SLICE_INTRAREFRESH_PARAM
+ * - #V4L2_CID_MPEG_VIDEOENC_NUM_BFRAMES
+ * - #V4L2_CID_MPEG_VIDEOENC_INSERT_SPS_PPS_AT_IDR
+ * - #V4L2_CID_MPEG_VIDEOENC_METADATA
+ * - #V4L2_CID_MPEG_VIDEOENC_METADATA_MV
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_METADATA_MV
+ * - #V4L2_CID_MPEG_VIDEOENC_QP_RANGE
+ * - #V4L2_CID_MPEG_VIDEOENC_HW_PRESET_TYPE_PARAM
+ * - #V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_EXTERNAL_RPS_CONTROL
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_EXTERNAL_RATE_CONTROL
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_ROI_PARAM
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_RECONCRC_PARAM
+ * - #V4L2_CID_MPEG_VIDEOENC_INSERT_VUI
+ * - #V4L2_CID_MPEG_VIDEOENC_INSERT_AUD
+ * - #V4L2_CID_MPEG_VIDEOENC_EXTEDED_COLORFORMAT
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_ALLIFRAME_ENCODE
+ * - #V4L2_CID_MPEG_VIDEOENC_H265_LEVEL
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_SLICE_LEVEL_ENCODE
+ *
+ * #### Setting Framerate
+ * The encoder framerate can be set with \c VIDIOC_S_PARM IOCTL by setting the numerator
+ * and denominator in `v4l2_streamparm.parm.output.timeperframe`.
+ *
+ * ### Supported Encoder Profiles
+ * #### H.264
+ * - V4L2_MPEG_VIDEO_H264_PROFILE_MAIN
+ * - V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE
+ * - V4L2_MPEG_VIDEO_H264_PROFILE_HIGH
+ *
+ * #### H.265
+ * - V4L2_MPEG_VIDEO_H265_PROFILE_MAIN
+ * - V4L2_MPEG_VIDEO_H265_PROFILE_MAIN10
+ *
+ * ### Encoder Output Metadata
+ * The encoder supports reporting frame related metadata, including motion vectors
+ * for that frame. See \c V4L2_CID_MPEG_VIDEOENC_METADATA,
+ * \c V4L2_CID_MPEG_VIDEOENC_METADATA_MV and \c V4L2_CID_MPEG_VIDEOENC_ENABLE_METADATA_MV
+ * for more information.
+ *
+ * ### EOS Handling
+ * The following sequence must be followed for sending EOS and recieving EOS
+ * from the encoder.
+ * -# Send EOS to encoder by queueing on the output plane a buffer with
+ * bytesused = 0 for the 0th plane (`v4l2_buffer.m.planes[0].bytesused = 0`).
+ * -# Dequeues buffers on the capture plane until it gets a buffer with bytesused = 0
+ * for the 0th plane.
+ *
+ * @note Currently, V4L2 plugins do not support odd resolution.
+ * @{
+ * @ingroup ee_extensions_group
+ */
+
+
+/**
+ * Defines the Control ID to configure encoder to drop frames while encoding.
+ *
+ * A value of type \c v4l2_enc_temporal_tradeoff_level_type must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_TEMPORAL_TRADEOFF_LEVEL (V4L2_CID_MPEG_BASE+528)
+
+/**
+ * Defines the Control ID to configure encoder slice length either in terms of MBs or bits.
+ *
+ * A pointer to a valid \c v4l2_enc_slice_length_param structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_SLICE_LENGTH_PARAM (V4L2_CID_MPEG_BASE+529)
+
+/**
+ * Defines the Control ID to configure encoder to encode particular region of frame in high
+ * quality.
+ *
+ * A pointer to a valid \c v4l2_enc_frame_ROI_params structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after requesting buffers on both the
+ * planes.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ROI_PARAMS (V4L2_CID_MPEG_BASE+530)
+
+/**
+ * Defines the Control ID to specify virtual buffer size in bits for encoder.
+ *
+ * A pointer to a valid \c v4l2_enc_virtual_buffer_size structure must be
+ * supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_VIRTUALBUFFER_SIZE (V4L2_CID_MPEG_BASE+531)
+
+/**
+ * Defines the Control ID to specify maximum number of reference frames that can be used.
+ *
+ * An integer value must be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_NUM_REFERENCE_FRAMES (V4L2_CID_MPEG_BASE+532)
+
+/**
+ * Defines the Control ID to specify the encoder slice intra refresh interval.
+ *
+ * A pointer to a valid \c v4l2_enc_slice_intrarefresh_param structure must be
+ * supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_SLICE_INTRAREFRESH_PARAM (V4L2_CID_MPEG_BASE+533)
+
+/**
+ * Defines the Control ID to set number of B frames to be encoded between two P frames.
+ *
+ * This works with H.264 encoder. This also works with H.265 encoder for Jetson Xavier and
+ * Jetson Xavier NX platforms. An integer value must be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_NUM_BFRAMES (V4L2_CID_MPEG_BASE+534)
+
+/**
+ * Defines the Control ID to enable/disable inserting SPS and PPS explicitly at IDR interval.
+ *
+ * A boolean value must be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_INSERT_SPS_PPS_AT_IDR (V4L2_CID_MPEG_BASE+535)
+
+/**
+ * Defines the Control ID to get encoder output metadata.
+ *
+ * A pointer to valid #v4l2_ctrl_video_metadata structure must be supplied with
+ * this control.
+ *
+ * @attention This control must be read after dequeueing a buffer successfully from
+ * the capture plane. The values in the structure are valid until the buffer is queued
+ * again.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_METADATA               (V4L2_CID_MPEG_BASE+536)
+
+/**
+ * Defines the Control ID to enable/disable encoder motion vector reporting.
+ *
+ * A boolean value must be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_METADATA_MV     (V4L2_CID_MPEG_BASE+537)
+
+/**
+ * Defines the Control ID to get encoder output motion vector metadata.
+ *
+ * A pointer to valid \c v4l2_ctrl_videoenc_outputbuf_metadata_MV structure must
+ * be supplied with this control.
+ *
+ * @attention This control must be read after dequeueing a buffer successfully from
+ * the capture plane. The values in the structure are valid until the buffer is queued
+ * again.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_METADATA_MV            (V4L2_CID_MPEG_BASE+538)
+
+/**
+ * Defines the Control ID to set QP range for I/P/B frames.
+ *
+ * A pointer to a valid \c v4l2_ctrl_video_qp_range structure must
+ * be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_QP_RANGE               (V4L2_CID_MPEG_BASE+539)
+
+/**
+ * Defines the Control ID to set encoder HW Preset type.
+ *
+ * A pointer to valid #v4l2_enc_hw_preset_type_param structure must
+ * be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_HW_PRESET_TYPE_PARAM   (V4L2_CID_MPEG_BASE+540)
+
+/**
+ * Defines the Control ID to provide input metadata for encoder buffer.
+ *
+ * A pointer to valid #v4l2_ctrl_videoenc_input_metadata structure must be
+ * supplied with this control.
+ *
+ * @attention This control must be called before queueing a buffer on the output
+ * plane. Use the bitwise OR of v4l2_enc_input_metadata_param in the
+ * v4l2_ctrl_videoenc_input_metadata.metadata_flag to provide different input
+ * metadata parameters in one s_ctrl call.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA         (V4L2_CID_MPEG_BASE+541)
+
+/**
+ * Defines the Control ID to configure encoder for external RPS control.
+ *
+ * A pointer to a valid #v4l2_enc_enable_ext_rps_ctr structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after requesting buffers on both the
+ * planes. The value for V4L2_CID_MPEG_VIDEOENC_NUM_REFERENCE_FRAMES, if being entered,
+ * must be set after this control.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_EXTERNAL_RPS_CONTROL (V4L2_CID_MPEG_BASE+542)
+
+/**
+ * Defines the Control ID to configure encoder for external rate control.
+ *
+ * A pointer to a valid #v4l2_enc_enable_ext_rate_ctr structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after requesting buffers on both the
+ * planes.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_EXTERNAL_RATE_CONTROL (V4L2_CID_MPEG_BASE+543)
+
+/**
+ * Defines the Control ID to configure ROI encoding for a session.
+ *
+ * A pointer to a valid #v4l2_enc_enable_roi_param structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after requesting buffers on both the
+ * planes.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_ROI_PARAM (V4L2_CID_MPEG_BASE+544)
+
+/**
+ * Defines the Control ID to configure Reconstructed CRC for a session.
+ *
+ * A pointer to a valid #v4l2_enc_enable_reconcrc_param structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after requesting buffers on both the
+ * planes.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_RECONCRC_PARAM  (V4L2_CID_MPEG_BASE+545)
+
+/**
+ * Control ID to enable/disable inserting VUI in SPS.
+ *
+ * A boolean value should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_INSERT_VUI (V4L2_CID_MPEG_BASE+546)
+
+/**
+ * Control ID to enable/disable inserting AUD(Access Unit Delimiter).
+ *
+ * A boolean value should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_INSERT_AUD (V4L2_CID_MPEG_BASE+547)
+
+/**
+ * Control ID to enable/disable setting extended color format.
+ *
+ * A boolean value should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane. Also this control should be
+ * enabled/disabled only after V4L2_CID_MPEG_VIDEOENC_INSERT_VUI is set
+ */
+#define V4L2_CID_MPEG_VIDEOENC_EXTEDED_COLORFORMAT (V4L2_CID_MPEG_BASE+548)
+
+/**
+ * Control ID to select which NVDEC IP to decode.
+ *
+ * @note This functionality is currently being deprecated and no longer
+ * functional.
+ *
+ * A v4l2_decode_instance_type should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_DECODE_INSTANCE (V4L2_CID_MPEG_BASE+549)
+/**
+ * Control ID to issue a pseudo POLL call on the fd opened in non blocking mode.
+ *
+ * A pointer to a valid #v4l2_ctrl_video_device_poll must be supplied with this control.
+ *
+ * @attention This should only be called when the Decoder or Encoder is opened with
+ * O_NONBLOCK flag.
+ */
+#define V4L2_CID_MPEG_VIDEO_DEVICE_POLL (V4L2_CID_MPEG_BASE+550)
+
+/**
+ * Control ID to set/clear the polling interrupt mode. Useful when a POLL issued from the
+ * application but wants the wait to be interrupted.
+ *
+ * A boolean value must be supplied with this control, True indicates polling interrupt shall be
+ * enabled and it shall stay enabled (i.e calls to POLL will return immediately) until a call to
+ * same control ID is made by passing a boolean 0 value.
+ *
+ * @attention This should only be called when the Decoder or Encoder is opened with
+ * O_NONBLOCK flag.
+ */
+#define V4L2_CID_MPEG_SET_POLL_INTERRUPT (V4L2_CID_MPEG_BASE+551)
+
+/**
+ * Control ID to enable/disable setting rate control two pass CBR.
+ *
+ * A boolean value should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_TWO_PASS_CBR (V4L2_CID_MPEG_BASE+552)
+
+/**
+ * Defines the Control ID to set the converter YUV Rescale method.
+ *
+ * A value of type \c v4l2_yuv_rescale_method must be supplied with this control.
+ *
+ * @attention This control must be set before requesting buffers on either plane.
+ */
+#define V4L2_CID_VIDEO_CONVERT_YUV_RESCALE_METHOD (V4L2_CID_MPEG_BASE+553)
+
+/**
+ * Control ID to enable maximum Performance.
+ *
+ * An integer value must be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_MAX_PERFORMANCE (V4L2_CID_MPEG_BASE+554)
+
+/**
+ * Control ID to enable/disable setting for all i-Frame encoding.
+ *
+ * A boolean value should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_ALLIFRAME_ENCODE (V4L2_CID_MPEG_BASE+555)
+
+/**
+ * Defines the Control ID to set buf api to be used by decoder/encoder.
+ *
+ * A boolean value should be supplied with this control, default is 0
+ * This has to be called before any other ioctls are used and cannot be changed.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ * This is internal ioctl due to be removed later.
+ */
+#define V4L2_CID_MPEG_VIDEO_BUF_API_TYPE (V4L2_CID_MPEG_BASE+556)
+
+/**
+ * Defines the Control ID to set cuda memory type to be used by decoder/encoder.
+ *
+ * This control can be used by the decoder to set the memory type for surfaces.
+ * A value of \c v4l2_cuda_mem_type needs to be set with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_CUDA_MEM_TYPE (V4L2_CID_MPEG_BASE+557)
+
+/**
+ * Defines the Control ID to set GPU ID to be used by decoder/encoder.
+ *
+ * An integer value should be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_CUDA_GPU_ID (V4L2_CID_MPEG_BASE+558)
+
+/**
+ * Defines the Control ID to set drop frames interval for decoder.
+ *
+ * An integer value should be supplied with this control. A value of "x"
+ * indicates every "x"th frame should be given out from the decoder, rest shall
+ * dropped after decoding.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEODEC_DROP_FRAME_INTERVAL (V4L2_CID_MPEG_BASE+559)
+
+/**
+ * Control ID to enable/disable setting for attaching VP8/9 headers.
+ * Only to be used for VP8/9 pixel format not for H264/5.
+ *
+ * A boolean value should be supplied with this control.
+ * If value is false headers will be disabled and true will enable the headers.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+ #define V4L2_CID_MPEG_VIDEOENC_VPX_HEADERS_WITH_FRAME (V4L2_CID_MPEG_BASE+560)
+
+/**
+ * Defines the control ID to set the H.265 encoder level.
+ *
+ * A v4l2_mpeg_video_h265_level must be passed.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_H265_LEVEL (V4L2_CID_MPEG_BASE+561)
+
+/**
+ * Control ID to enable/disable slice level encode output.
+ *
+ * A boolean value should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_SLICE_LEVEL_ENCODE (V4L2_CID_MPEG_BASE+562)
+
+/* L4T BSP 32.5.x */
+/**
+ * Defines the Control ID to set Picture Order Count property in frames.
+ *
+ * This works only with H.264 encoder. An integer value must be supplied with this
+ * control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_POC_TYPE (V4L2_CID_MPEG_BASE+563)
+
+/* L4T BSP 32.6.x */
+/**
+ * Defines the Control ID to set Sample Aspect Ratio width for H265 VUI encoding.
+ *
+ * An integer value must be supplied with this control.
+ * The VUI Sample Aspect Ratio indicator for H265 follows the standard enum defined for
+ * v4l2_mpeg_video_h264_vui_sar_idc.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_H265_VUI_EXT_SAR_WIDTH (V4L2_CID_MPEG_BASE+564)
+
+/**
+ * Defines the Control ID to set Sample Aspect Ratio height for H265 VUI encoding.
+ *
+ * An integer value must be supplied with this control.
+ * The VUI Sample Aspect Ratio indicator for H265 follows the standard enum defined
+ * for v4l2_mpeg_video_h264_vui_sar_idc.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_H265_VUI_EXT_SAR_HEIGHT (V4L2_CID_MPEG_BASE+565)
+
+/**
+ * Defines the Control ID to force INTRA frame.
+ *
+ * This control can be used by encoder to force encoding an intra frame.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_FORCE_INTRA_FRAME (V4L2_CID_MPEG_BASE+566)
+
+/**
+ * Defines the Control ID to force IDR frame.
+ *
+ * This control can be used by encoder to force encoding an idr frame.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_FORCE_IDR_FRAME (V4L2_CID_MPEG_BASE+567)
+
+ /**
+ * Defines the Control ID to set low latency to be used by decoder.
+ *
+ * This control can be used by decoder to set low latency for streams having
+ * I and IPPP frames.
+ *
+ * @attention This control must be set before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_CUDA_LOW_LATENCY (V4L2_CID_MPEG_BASE+568)
+
+/* L4T BSP 32.7.x */
+/**
+ * Defines the Control ID to enable lossless H.264/H.265 encoding.
+ *
+ * An boolean value must be supplied with this control. Default is 0.
+ * Lossless encoding is supported only for YUV444 8/10-bit format.
+ * @note This control must be set in case of H.264 YUV444 encoding as
+ * it does not support lossy encoding.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_LOSSLESS (V4L2_CID_MPEG_BASE+569)
+
+/**
+ * Defines the Control ID to set chroma_factor_idc for H.265 encoding.
+ *
+ * An integer value must be supplied with this control. Default is 1, and
+ * 3 for YUV444 8/10-bit format.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_H265_CHROMA_FACTOR_IDC (V4L2_CID_MPEG_BASE+570)
+/** @} */
+
+/** @addtogroup V4L2Dec */
+/** @{ */
+/**
+ * Enum v4l2_skip_frames_type, possible methods for decoder skip frames. */
+enum v4l2_skip_frames_type {
+    /** Do not skip any frame. */
+    V4L2_SKIP_FRAMES_TYPE_NONE = 0,
+    /** Skip all non-reference frames. */
+    V4L2_SKIP_FRAMES_TYPE_NONREF = 1,
+    /** Skip all frames except IDR */
+    V4L2_SKIP_FRAMES_TYPE_DECODE_IDR_ONLY = 2,
+};
+
+/**
+ * Enum v4l2_cuda_mem_type, possible methods for cuda memory tpye. */
+enum v4l2_cuda_mem_type {
+    /** Memory type device. */
+    V4L2_CUDA_MEM_TYPE_DEVICE = 0,
+    /** Memory type host. */
+    V4L2_CUDA_MEM_TYPE_PINNED = 1,
+    /** Memory type unified. */
+    V4L2_CUDA_MEM_TYPE_UNIFIED = 2,
+};
+
+/**
+ * Enum v4l2_videodec_input_error_type, possible error types for input stream. */
+enum v4l2_videodec_input_error_type {
+    /** no error. */
+    V4L2_DEC_ERROR_NONE = 0x0,
+    /** sps error. */
+    V4L2_DEC_ERROR_SPS = 0x1,
+    /** pps error. */
+    V4L2_DEC_ERROR_PPS = 0x2,
+    /** slice header error. */
+    V4L2_DEC_ERROR_SLICE_HDR = 0x4,
+    /** missing reference frame error. */
+    V4L2_DEC_ERROR_MISSING_REF_FRAME = 0x8,
+    /** VPS error. */
+    V4L2_DEC_ERROR_VPS = 0x10,
+};
+
+/**
+ * Holds the decoder error status metadata for the frame.
+ */
+typedef struct v4l2_ctrl_videodec_statusmetadata_
+{
+    /** Error types:
+     *  bit 0: Fatal
+     *  bit 1: MB level syntax
+     *  bit 2: Missing Slice(s)
+     *  bit 3: PrevFrameLostFlag */
+    __u32  DecodeError;
+    /** Number of macro blocks decoded without error. */
+    __u32  DecodedMBs;
+    /** Number of macro blocks where error was concealed. */
+    __u32  ConcealedMBs;
+    /** POC of the reference frame used for concealment. */
+    __u32  nConcealedFromPOC;
+    /** Time required to decode the frame, in microseconds. */
+    __u32  FrameDecodeTime;
+}v4l2_ctrl_videodec_statusmetadata;
+
+/**
+ * Holds the the frame specific metadata for a reference frame.
+ */
+typedef struct v4l2_ctrl_videodec_refframe_metadata_
+{
+    /** Boolean value indicating if the frame is present in DPB. */
+    __u32 bPresent;
+    /** Boolean value indicating if the frame is an IDR. */
+    __u32 bIdrFrame;
+    /** Boolean value indicating if the frame is a long term reference frame. */
+    __u32 bLTRefFrame;
+    /** Boolean value indicating if it is a predicted frame. */
+    __u32 bPredicted;
+    /** Picture order count of the frame. */
+    __u32 nPictureOrderCnt;
+    /** Frame number. Resets to zero for an IDR frame. */
+    __u32 nFrameNum;
+    /** Long Term Frame Index of the frame. */
+    __u32 nLTRFrameIdx;
+} v4l2_ctrl_videodec_refframe_metadata;
+
+/**
+ * Holds the the frame specific metadata for the current frame.
+ */
+typedef struct v4l2_ctrl_videodec_currentframe_metadata_
+{
+    /** Boolean value indicating if the current frame is a reference frame. */
+    __u32 bRefFrame;
+    /** Boolean value indicating if the current frame is an IDR. */
+    __u32 bIdrFrame;
+    /** Boolean value indicating if the current frame is a long term reference frame. */
+    __u32 bLTRefFrame;
+    /** Picture order count of the current frame. */
+    __u32 nPictureOrderCnt;
+    /** Frame number. Resets to zero for an IDR frame. */
+    __u32 nFrameNum;
+    /** Long Term Frame Index of the current frame. */
+    __u32 nLTRFrameIdx;
+} v4l2_ctrl_videodec_currentframe_metadata;
+
+/**
+ * Holds the decoder DPB info metadata.
+ */
+typedef struct v4l2_ctrl_videodec_dpbinfometadata_
+{
+    /** Metadata for the current decoded frame. */
+    v4l2_ctrl_videodec_currentframe_metadata currentFrame;
+    /** Number of active frames present in the DPB. */
+    __u32 nActiveRefFrames;
+    /** An array of metadatas for the active frames in the DPB. Only
+     *  nActiveRefFrames elements in the array are valid. */
+    v4l2_ctrl_videodec_refframe_metadata RPSList[16];
+} v4l2_ctrl_videodec_dpbinfometadata;
+
+/**
+ * Holds H.264 specific decoder metadata for the frame.
+ */
+typedef struct v4l2_ctrl_h264dec_bufmetadata_
+{
+    /** Holds the number of bits in the frame. */
+    __u32 nFrameNumBits;
+    /** Type of frame:
+     *  0 = B
+     *  1 = P
+     *  2 = I */
+    __u32  FrameType;
+    /** Holds the current DPB information of the decoder. */
+    v4l2_ctrl_videodec_dpbinfometadata dpbInfo;
+}v4l2_ctrl_h264dec_bufmetadata;
+
+/**
+ * Holds H.265 specific decoder metadata for the frame.
+ */
+typedef struct v4l2_ctrl_hevcdec_bufmetadata_
+{
+    /** Holds the number of bits in the frame. */
+    __u32 nPocLsbBits;
+    /** Type of frame:
+     *  0 = B
+     *  1 = P
+     *  2 = I */
+    __u32  FrameType;
+    /** Holds the current DPB information of the decoder. */
+    v4l2_ctrl_videodec_dpbinfometadata dpbInfo;
+}v4l2_ctrl_hevcdec_bufmetadata;
+
+/**
+ * Holds the video decoder input header error metadata for a frame.
+ */
+typedef struct v4l2_ctrl_videodec_inputbuf_metadata_
+{
+    /** Bits represent types of error as defined
+     *  with v4l2_videodec_input_error_type. */
+    __u32 nBitStreamError;
+} v4l2_ctrl_videodec_inputbuf_metadata;
+
+/**
+ * Holds the video decoder output metadata for a frame.
+ */
+typedef struct v4l2_ctrl_videodec_outputbuf_metadata_
+{
+    /** Color primaries. */
+    __u8 ucColorPrimaries;
+    /** Transfer characteristics. */
+    __u8 ucTransferCharacteristics;
+    /** Matrix coefficients. */
+    __u8 ucMatrixCoefficients;
+    /** Boolean value indicating if \c FrameDecStats has valid contents. */
+    __u32 bValidFrameStatus;
+    /** Frame decode statistics. */
+    v4l2_ctrl_videodec_statusmetadata    FrameDecStats;
+    /** Codec specific metadata for the frame. */
+    union {
+        /** H.264 specific metadata. */
+        v4l2_ctrl_h264dec_bufmetadata H264DecParams;
+        /** H.265 specific metadata. */
+        v4l2_ctrl_hevcdec_bufmetadata HEVCDecParams;
+    }CodecParams;
+} v4l2_ctrl_videodec_outputbuf_metadata;
+/** @} */
+
+/** @addtogroup V4L2Enc */
+/** @{ */
+
+/**
+ * Specifies the types of encoder temporal tradeoff levels
+ */
+enum v4l2_enc_temporal_tradeoff_level_type {
+    /** Do not drop any buffers. */
+    V4L2_ENC_TEMPORAL_TRADEOFF_LEVEL_DROPNONE = 0,
+    /** Drop 1 in every 5 buffers. */
+    V4L2_ENC_TEMPORAL_TRADEOFF_LEVEL_DROP1IN5,
+    /** Drop 1 in every 3 buffers. */
+    V4L2_ENC_TEMPORAL_TRADEOFF_LEVEL_DROP1IN3,
+    /** Drop 1 in every 2 buffers. */
+    V4L2_ENC_TEMPORAL_TRADEOFF_LEVEL_DROP1IN2,
+    /** Drop 2 in every 3 buffers. */
+    V4L2_ENC_TEMPORAL_TRADEOFF_LEVEL_DROP2IN3,
+};
+
+/**
+ * Specifies the encoder HW Preset type.
+ */
+enum v4l2_enc_hw_preset_type {
+    /** Encoder HWPreset DISABLED. */
+    V4L2_ENC_HW_PRESET_DISABLE = 0,
+    /** Encoder HWPreset with per frame encode time UltraFast. */
+    V4L2_ENC_HW_PRESET_ULTRAFAST = 1,
+    /** Encoder HWPreset with per frame encode time Fast. */
+    V4L2_ENC_HW_PRESET_FAST,
+    /** Encoder HWPreset with per frame encode time Medium. */
+    V4L2_ENC_HW_PRESET_MEDIUM,
+    /** Encoder HWPreset with per frame encode time Slow. */
+    V4L2_ENC_HW_PRESET_SLOW,
+};
+
+/**
+ * Holds encoder HW Preset type parameters
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_HW_PRESET_TYPE_PARAM IOCTL.
+ */
+typedef struct v4l2_enc_hw_preset_type_param_
+{
+    /** Type in which the encoder hw preset is specified, one of type #v4l2_enc_hw_preset_type. */
+    enum v4l2_enc_hw_preset_type hw_preset_type;
+    /** Boolean value indicating if encoder set to max clock. */
+    __u8 set_max_enc_clock;
+}v4l2_enc_hw_preset_type_param;
+
+/**
+ * Enum specifying the type of slice length.
+ */
+enum v4l2_enc_slice_length_type {
+    /** Slice size is specified in terms of number of bytes. */
+    V4L2_ENC_SLICE_LENGTH_TYPE_BITS = 0,
+    /** Slice size is specified in terms of number of macroblocks. */
+    V4L2_ENC_SLICE_LENGTH_TYPE_MBLK,
+};
+
+/**
+ * Specifies the input buffer metadata flag.
+ */
+enum v4l2_enc_input_metadata_param {
+    /** Input metadata structure contains ROI parameters.  */
+    V4L2_ENC_INPUT_ROI_PARAM_FLAG = 1,
+    /** Input metadata structure contains GDR parameters.  */
+    V4L2_ENC_INPUT_GDR_PARAM_FLAG = 1 << 1,
+    /** Input metadata structure contains External RPS parameters.  */
+    V4L2_ENC_INPUT_RPS_PARAM_FLAG = 1 << 2,
+    /** Input metadata structure contains External RC parameters.  */
+    V4L2_ENC_INPUT_RC_PARAM_FLAG = 1 << 3,
+    /** Input metadata structure contains ReconCRC parameters.  */
+    V4L2_ENC_INPUT_RECONCRC_PARAM_FLAG = 1 << 4,
+};
+
+/**
+ * Defines the possible levels for H.265 encoder.
+ */
+enum v4l2_mpeg_video_h265_level {
+
+    V4L2_MPEG_VIDEO_H265_LEVEL_1_0_MAIN_TIER = 0,
+    V4L2_MPEG_VIDEO_H265_LEVEL_1_0_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_2_0_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_2_0_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_2_1_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_2_1_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_3_0_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_3_0_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_3_1_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_3_1_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_4_0_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_4_0_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_4_1_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_4_1_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_5_0_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_5_0_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_5_1_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_5_1_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_5_2_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_5_2_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_6_0_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_6_0_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_6_1_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_6_1_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_6_2_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_6_2_HIGH_TIER,
+};
+
+/**
+ * Holds encoder slice length parameters, to be used with
+ * \c V4L2_CID_MPEG_VIDEOENC_SLICE_LENGTH_PARAM IOCTL.
+ */
+typedef struct v4l2_enc_slice_length_param_
+{
+    /** Type in which the slice length is specified, one of type \c v4l2_enc_slice_length_type. */
+    enum v4l2_enc_slice_length_type slice_length_type;
+    /** Size of the slice in either number of bytes or number of macro blocks. */
+    __u32   slice_length;
+}v4l2_enc_slice_length_param;
+
+/**
+ * Holds encoder virtual buffer size parameters, to be used with
+ * \c V4L2_CID_MPEG_VIDEOENC_VIRTUALBUFFER_SIZE IOCTL.
+ */
+typedef struct v4l2_enc_virtual_buffer_size_
+{
+    /** Size of the virtual buffer, in bits. */
+    __u32   size;
+}v4l2_enc_virtual_buffer_size;
+
+/**
+ * Holds encoder number of reference frame parameters, to be used with
+ * \c V4L2_CID_MPEG_VIDEOENC_NUM_REFERENCE_FRAMES IOCTL.
+ *
+ * This is not supported for H.265.
+ */
+typedef struct v4l2_enc_num_ref_frames_
+{
+    /** Number of reference frames. */
+    __u32   frames;
+}v4l2_enc_num_ref_frames;
+
+/**
+ * Holds encoder slice intrareferesh parameters, to be used with
+ * \c V4L2_CID_MPEG_VIDEOENC_SLICE_INTRAREFRESH_PARAM IOCTL.
+ */
+typedef struct v4l2_enc_slice_intrarefresh_param_
+{
+    /** Slice intrarefresh interval, in number of slices. */
+    __u32   interval;
+}v4l2_enc_slice_intrarefresh_param;
+
+/**
+ * Defines the maximum number of ROI regions supported by the encoder.
+ */
+#define V4L2_MAX_ROI_REGIONS 8
+
+/**
+ * Holds the encoder quality parameters for a single ROI region.
+ */
+typedef struct v4l2_enc_ROI_param_
+{
+    /** Region of interest rectangle. */
+    struct v4l2_rect  ROIRect;
+    /** QP delta for the region. */
+    __s32   QPdelta;
+} v4l2_enc_ROI_param;
+
+/**
+ * Holds the encoder frame ROI parameters
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_ROI_PARAMS IOCTL.
+ */
+typedef struct v4l2_enc_frame_ROI_params_
+{
+    /** Number of regions. */
+    __u32 num_ROI_regions;
+    /** Array of indiviudal ROI parameters. */
+    v4l2_enc_ROI_param ROI_params[V4L2_MAX_ROI_REGIONS];
+    /** Config store integer to which this control is to be applied.
+     *  This must be same as the value of config store of \c v4l2_buffer to which
+     *  the ROI params is applied. */
+    __u32   config_store;
+}v4l2_enc_frame_ROI_params;
+
+/**
+ * Holds the motion vector parameters for a single block.
+ * For H.264, nvenc provides one motion vector per 16x16 block(Macroblock).
+ * For H.265, nvenc provides one motion vector per 32x32 block(Coded Tree Block).
+ */
+typedef struct MVInfo_ {
+    /** Number of pixels the macro block moved in horizontal direction. */
+    __s32 mv_x   : 16;
+    /** Number of pixels the macro block moved in vertical direction. */
+    __s32 mv_y   : 14;
+    /** Temporal hints used by hardware for Motion Estimation. */
+    __u32 weight : 2;
+} MVInfo;
+
+/**
+ * Holds the motion vector parameters for one complete frame.
+ */
+typedef struct v4l2_ctrl_videoenc_outputbuf_metadata_MV_ {
+    /** Size of the pMVInfo buffer, in bytes. */
+    __u32 bufSize;
+    /** Pointer to the buffer containing the motion vectors. */
+    MVInfo *pMVInfo;
+} v4l2_ctrl_videoenc_outputbuf_metadata_MV;
+
+/**
+ * Maximum number of reference frames supported by the encoder.
+ */
+#define V4L2_MAX_REF_FRAMES  8
+
+/**
+ * Holds the RPS List parameters of encoded frame.
+ */
+typedef struct v4l2_enc_frame_full_prop_
+{
+    /** Unique frame ID. */
+    __u32  nFrameId;
+    /** Boolean value indicating if current frame is an IDR. */
+    __u8   bIdrFrame;
+    /** Boolean value indicating if set Long Term Ref Flag. */
+    __u8   bLTRefFrame;
+    /** Picture Order Count. */
+    __u32  nPictureOrderCnt;
+    /** FrameNum. */
+    __u32  nFrameNum;
+    /** LongTermFrameIdx of a picture. */
+    __u32  nLTRFrameIdx;
+} v4l2_enc_frame_full_prop;
+
+/**
+ * Holds the encoder output metadata for a frame, to be used with
+ * \c V4L2_CID_MPEG_VIDEOENC_METADATA IOCTL.
+ */
+typedef struct v4l2_ctrl_videoenc_outputbuf_metadata_
+{
+    /** Boolean value indicating if current frame is a key frame. */
+    __u8 KeyFrame;
+    /** Boolean value indicating end of frame in case of multi slice encoding. */
+    __u8 EndofFrame;
+    /** Average QP value of the frame. */
+    __u16 AvgQP;
+    /** Boolean value indicating if current frame is a golden or alternate frame. */
+    __u8 bIsGoldenOrAlternateFrame;
+    /** CRC for Reconstructed frame. */
+    __u8 bValidReconCRC;
+    /** Recon Y-frame CRC */
+    __u32 ReconFrame_Y_CRC;
+    /** Recon U-frame CRC */
+    __u32 ReconFrame_U_CRC;
+    /** Recon V-frame CRC */
+    __u32 ReconFrame_V_CRC;
+    /** Number of bits needed to encode the frame. */
+    __u32 EncodedFrameBits;
+    /** Minumum QP value in the frame. */
+    __u32 FrameMinQP;
+    /** Maximum QP value in the frame. */
+    __u32 FrameMaxQP;
+    /** RPS Feedback. */
+    __u32 bRPSFeedback_status;
+    /**  Reference frame ID used for Motion Estimation of current frame,
+         ignored for IDR */
+    __u32 nCurrentRefFrameId;
+    /** Number of active reference frames. */
+    __u32 nActiveRefFrames;
+    /** RPS List including most recent frame if it is reference frame. */
+    v4l2_enc_frame_full_prop RPSList[V4L2_MAX_REF_FRAMES];
+} v4l2_ctrl_videoenc_outputbuf_metadata;
+
+/**
+ * Holds the metadata parameters for video encoder and decoder.
+ *
+ * The metadata is valid for the buffer with index \c buffer_index after the
+ * buffer is dequeued until it is queued again.
+ */
+typedef struct v4l2_ctrl_video_metadata_
+{
+    /** A pointer to #v4l2_ctrl_videodec_inputbuf_metadata structure.
+     * This must be a valid pointer when used with #V4L2_CID_MPEG_VIDEODEC_INPUT_METADATA
+     * IOCTL. */
+    v4l2_ctrl_videodec_inputbuf_metadata *VideoDecHeaderErrorMetadata;
+    /** A pointer to #v4l2_ctrl_videodec_outputbuf_metadata structure.
+     * This must be a valid pointer when used with #V4L2_CID_MPEG_VIDEODEC_METADATA
+     * IOCTL. */
+    v4l2_ctrl_videodec_outputbuf_metadata *VideoDecMetadata;
+    /** A pointer to #v4l2_ctrl_videoenc_outputbuf_metadata structure.
+     * This must be a valid pointer when used with #V4L2_CID_MPEG_VIDEOENC_METADATA
+     * IOCTL. */
+    v4l2_ctrl_videoenc_outputbuf_metadata *VideoEncMetadata;
+    /** A pointer to #v4l2_ctrl_videoenc_outputbuf_metadata_MV structure.
+     * This must be a valid pointer when used with #V4L2_CID_MPEG_VIDEOENC_METADATA_MV
+     * IOCTL. */
+    v4l2_ctrl_videoenc_outputbuf_metadata_MV *VideoEncMetadataMV;
+    /** Index of the buffer whose metadata is required. */
+    __u32 buffer_index;
+} v4l2_ctrl_video_metadata;
+
+/**
+ * Holds the encoder GDR parameters
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA IOCTL.
+ */
+typedef struct v4l2_enc_gdr_params_
+{
+    /** Parameter for GDR (Intra Refresh) for specified number of frames. */
+    __u32 nGDRFrames;
+} v4l2_enc_gdr_params;
+
+/**
+ * Holds the params to configure encoder for external rps control
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_ENABLE_EXTERNAL_RPS_CONTROL IOCTL.
+ */
+typedef struct v4l2_enc_enable_ext_rps_ctrl_
+{
+    /** Boolean value indicating if enabled External RPS control. */
+    __u8 bEnableExternalRPS;
+    /** Boolean value indicating if allowed gap in frame number. */
+    __u8 bGapsInFrameNumAllowed;
+    /* TODO : Check for field details. */
+    __u32 nH264FrameNumBits;
+    /* TODO : Check for field details. */
+    __u32 nH265PocLsbBits;
+}v4l2_enc_enable_ext_rps_ctr;
+
+
+/**
+ * Holds the encoder frame property.
+ */
+typedef struct _v4l2_enc_frame_prop
+{
+    /** unique Id. */
+    __u32 nFrameId;
+    /** Long Term Ref Flag. */
+    __u8 bLTRefFrame;
+} v4l2_enc_frame_prop;
+
+/**
+ * Holds the encoder frame external rps control parameters
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA IOCTL.
+ */
+typedef struct v4l2_enc_frame_ext_rps_ctrl_params_
+{
+    /** unique Id of current frame. */
+    __u32 nFrameId;
+    /** Boolean value indicating if current frame referenced or non-referenced. */
+    __u8 bRefFrame;
+    /** Boolean value indicating if current frame long Term Ref Flag. */
+    __u8 bLTRefFrame;
+   /** Max Number of reference frames to use for inter-motion search. */
+    __u32 nMaxRefFrames;
+    /** # of valid entries in RPS, 0 means IDR. */
+    __u32 nActiveRefFrames;;
+    /**  frame id of reference frame to be used for motion search, ignored for IDR. */
+    __u32 nCurrentRefFrameId;
+    /** Array of RPS */
+    v4l2_enc_frame_prop RPSList[V4L2_MAX_REF_FRAMES];
+}v4l2_enc_frame_ext_rps_ctrl_params;
+
+
+/**
+ * Holds the params to configure encoder for external rate control mode
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_ENABLE_EXTERNAL_RATE_CONTROL IOCTL.
+ */
+typedef struct v4l2_enc_enable_ext_rate_ctrl_
+{
+    /** Boolean value indicating if enabled External Picture RC. */
+    __u8 bEnableExternalPictureRC;
+    /** Max QP per session when external picture RC enabled. */
+    __u32 nsessionMaxQP;
+}v4l2_enc_enable_ext_rate_ctr;
+
+/**
+ * Holds the encoder frame external rate control parameters
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA ioctl.
+ */
+typedef struct v4l2_enc_frame_ext_rate_ctrl_params_
+{
+    /** Target frame bits. */
+    __u32 nTargetFrameBits;
+    /** Frame start QP. */
+    __u32 nFrameQP;
+    /** Frame min QP. */
+    __u32 nFrameMinQp;
+    /** Frame max QP. */
+    __u32 nFrameMaxQp;
+    /** Frame min QP deviation. */
+    __u32 nMaxQPDeviation;
+}v4l2_enc_frame_ext_rate_ctrl_params;
+
+/**
+ * Holds the params to configure encoder for ROI parameters encoding
+ *
+ * Must be used with #V4L2_CID_MPEG_VIDEOENC_ENABLE_ROI_PARAM IOCTL.
+ */
+typedef struct v4l2_enc_enable_roi_param_
+{
+    /** Boolean value to indicating ROI param encoding. */
+    __u8 bEnableROI;
+}v4l2_enc_enable_roi_param;
+
+/**
+ * Holds the params to configure encoder for Reconstructed CRC encoding
+ *
+ * Must be used with #V4L2_CID_MPEG_VIDEOENC_ENABLE_RECONCRC_PARAM IOCTL.
+ */
+typedef struct v4l2_enc_enable_reconcrc_param_
+{
+    /** Boolean value to indicating Reconstructed CRC encoding. */
+    __u8 bEnableReconCRC;
+}v4l2_enc_enable_reconcrc_param;
+
+/**
+ * Holds the encoder frame Reconstructed CRC parameters.
+ *
+ * Must be used with #V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA IOCTL.
+ */
+typedef struct v4l2_enc_frame_ReconCRC_params_
+{
+    /** Rectangle to specify the co-ordinates of the input frame
+    * used to calculate reconstructed picture CRC. */
+    struct v4l2_rect  ReconCRCRect;
+}v4l2_enc_frame_ReconCRC_params;
+
+/**
+ * Holds the encoder frame input metadata parameters.
+ *
+ * Must be used with #V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA IOCTL.
+ */
+typedef struct v4l2_ctrl_videoenc_input_metadata_
+{
+    /** Flag to indicate which inputbuffer metadata is valid. */
+    __u32    flag;
+    /** Pointer to the ROI params structure when ROI param is in metadata_flag. */
+    v4l2_enc_frame_ROI_params *VideoEncROIParams;
+    /** Pointer to the Reconstructed CRC parameter structure when ReconCRC param is in
+    * metadata flag. */
+    v4l2_enc_frame_ReconCRC_params *VideoReconCRCParams;
+    /** Pointer to the GDR params structure when GDR param is in metadata_flag. */
+    v4l2_enc_gdr_params   *VideoEncGDRParams;
+    /** Pointer to the External RPL control parameter structure when RPS param is in
+    * metadata flag. */
+    v4l2_enc_frame_ext_rps_ctrl_params *VideoEncRPSParams;
+    /** Pointer to the External Rate control parameter structure when RC param is in
+    * metadata flag. */
+    v4l2_enc_frame_ext_rate_ctrl_params *VideoEncExtRCParams;
+    /** Config store integer to which these parameters are to be applied.
+     *  This must be same as the value of config store of queued v4l2_buffer
+     *   for which these parameters are valid. */
+    __u32    config_store;
+} v4l2_ctrl_videoenc_input_metadata;
+
+/**
+ * Setting Qp values in #v4l2_ctrl_video_qp_range to QP_RETAIN_VAL
+ * retains default or previously set QP values.
+ */
+#define QP_RETAIN_VAL -1
+
+/**
+ * Holds the encoder frame min/max QP parameters.
+ *
+ * Must be used with #V4L2_CID_MPEG_VIDEOENC_QP_RANGE IOCTL.
+ */
+typedef struct _v4l2_ctrl_video_qp_range
+{
+    /** Minimum QP value for I frame. */
+    __u32 MinQpI;
+    /** Maximum QP value for I frame. */
+    __u32 MaxQpI;
+    /** Minimum QP value for P frame. */
+    __u32 MinQpP;
+    /** Maximum QP value for P frame. */
+    __u32 MaxQpP;
+    /** Minimum QP value for B frame. */
+    __u32 MinQpB;
+    /** Maximum QP value for B frame. */
+    __u32 MaxQpB;
+} v4l2_ctrl_video_qp_range;
+/** @} */
+
+/** @addtogroup V4L2Conv */
+/** @{ */
+
+/**
+ * Enum specifying types of buffer layouts.
+ */
+enum v4l2_nv_buffer_layout {
+    V4L2_NV_BUFFER_LAYOUT_PITCH = 0,  /**< Pitch Linear Layout. */
+    V4L2_NV_BUFFER_LAYOUT_BLOCKLINEAR = 1, /**< Block Linear Layout. */
+};
+
+/**
+ * Specifies the types of rotation/flip algorithms.
+ */
+enum v4l2_flip_method {
+    V4L2_FLIP_METHOD_IDENTITY = 0, /**< Identity (no rotation). */
+    V4L2_FLIP_METHOD_90L = 1,      /**< Rotate counter-clockwise 90 degrees. */
+    V4L2_FLIP_METHOD_180 = 2,      /**< Rotate 180 degrees. */
+    V4L2_FLIP_METHOD_90R = 3,      /**< Rotate clockwise 90 degrees. */
+    V4L2_FLIP_METHOD_HORIZ = 4,    /**< Flip horizontally. */
+    V4L2_FLIP_METHOD_INVTRANS = 5, /**< Flip across upper right/lower left diagonal. */
+    V4L2_FLIP_METHOD_VERT = 6,     /**< Flip vertically. */
+    V4L2_FLIP_METHOD_TRANS = 7,    /**< Flip across upper left/lower right diagonal. */
+};
+
+/**
+ * Specifies the types of interpolation methods.
+ */
+enum v4l2_interpolation_method {
+  V4L2_INTERPOLATION_NEAREST = 1,   /**< Nearest interpolation method */
+  V4L2_INTERPOLATION_BILINEAR = 2,  /**< Bi-Linear interpolation method */
+  V4L2_INTERPOLATION_5_TAP = 3,     /**< 5-Tap interpolation method */
+  V4L2_INTERPOLATION_10_TAP = 4,    /**< 10-Tap interpolation method */
+  V4L2_INTERPOLATION_SMART = 5,     /**< Smart interpolation method */
+  V4L2_INTERPOLATION_NICEST = 6,    /**< Nicest interpolation method */
+};
+
+/**
+ * Specifies the types of TNR algorithms.
+ */
+enum v4l2_tnr_algorithm {
+  V4L2_TNR_ALGO_ORIGINAL = 0,           /**< Default TNR algorithm. */
+  V4L2_TNR_ALGO_OUTDOOR_LOW_LIGHT = 1,  /**< Outdoor Low Light TNR algorithm. */
+  V4L2_TNR_ALGO_OUTDOOR_MEDIUM_LIGHT = 2, /**< Outdoor Medium Light TNR algorithm. */
+  V4L2_TNR_ALGO_OUTDOOR_HIGH_LIGHT = 3, /**< Outdoor High Light TNR algorithm. */
+  V4L2_TNR_ALGO_INDOOR_LOW_LIGHT = 4, /**< Indoor Low Light TNR algorithm. */
+  V4L2_TNR_ALGO_INDOOR_MEDIUM_LIGHT = 5, /**< Indoor Medium Light TNR algorithm. */
+  V4L2_TNR_ALGO_INDOOR_HIGH_LIGHT = 6, /**< Indoor High Light TNR algorithm. */
+};
+
+/**
+ * Specifies the types of YUV rescale methods.
+ */
+enum v4l2_yuv_rescale_method {
+  /**< Disable */
+  V4L2_YUV_RESCALE_NONE = 0,
+  /**< Standard(limited range [16 235]) to extension(full range [0 255]) */
+  V4L2_YUV_RESCALE_STD_TO_EXT = 1,
+  /**< Extension(full range [0 255] to standard(limited range [16 235]) */
+  V4L2_YUV_RESCALE_EXT_TO_STD = 2,
+};
+
+typedef struct v4l2_ctrl_video_displaydata_
+{
+    __u32 masteringdisplaydatapresent;
+}v4l2_ctrl_video_displaydata;
+
+/**
+ * HDR Metadata.
+ */
+
+typedef struct _v4l2_ctrl_video_hdrmasteringdisplaydata
+{
+    // idx 0 : G, 1 : B, 2 : R
+    __u16 display_primaries_x[3];       // normalized x chromaticity cordinate. It shall be in the range of 0 to 50000
+    __u16 display_primaries_y[3];       // normalized y chromaticity cordinate. It shall be in the range of 0 to 50000
+    __u16 white_point_x;    // normalized x chromaticity cordinate of white point of mastering display
+    __u16 white_point_y;    // normalized y chromaticity cordinate of white point of mastering display
+    __u32 max_display_parameter_luminance;      // nominal maximum display luminance in units of 0.0001 candelas per square metre
+    __u32 min_display_parameter_luminance;      // nominal minimum display luminance in units of 0.0001 candelas per square metre
+} v4l2_ctrl_video_hdrmasteringdisplaydata;
+
+
+/**
+ * Poll device
+ */
+typedef struct _v4l2_ctrl_video_device_poll
+{
+    __u16 req_events;    // Requested events, a bitmask of POLLIN, POLLOUT, POLLERR, POLLPRI.
+    __u16 resp_events;    // Returned events a similar bitmask of above events.
+} v4l2_ctrl_video_device_poll;
+
+/** @} */
+
+
+
+/**
+ * @file
+ * <b>NVIDIA Multimedia Utilities: Buffering and Transform/Composition/Blending</b>
+ *
+ */
+
+/**
+ * Defines the maximum number of planes for a video frame.
+ */
+#define MAX_NUM_PLANES 4
+
+/**
+ * Defines NvBuffer Version.
+ */
+typedef enum
+{
+  /** L4T BSP r32.3.x - r32.4.x */
+  NvBufferPixFmtVersion_Legacy,
+  /** L4T BSP r32.5.x and newer */
+  NvBufferPixFmtVersion_New,
+} NvBufferPixFmtVersion;
+
+/**
+ * Defines Payload types for NvBuffer.
+ */
+typedef enum
+{
+  /** buffer payload with HW memory handle for set of planes. */
+  NvBufferPayload_SurfArray,
+  /** buffer payload with HW memory handle for specific memory size. */
+  NvBufferPayload_MemHandle,
+} NvBufferPayloadType;
+
+/**
+ * Defines Layout formats for NvBuffer video planes.
+ */
+typedef enum
+{
+  /** Pitch Layout. */
+  NvBufferLayout_Pitch,
+  /** BlockLinear Layout. */
+  NvBufferLayout_BlockLinear,
+} NvBufferLayout;
+
+/**
+ * Defines memory access flags for NvBuffer.
+ */
+typedef enum
+{
+  /** Memory read. */
+  NvBufferMem_Read,
+  /** Memory write. */
+  NvBufferMem_Write,
+  /** Memory read & write. */
+  NvBufferMem_Read_Write,
+} NvBufferMemFlags;
+
+/**
+ * Defines tags that identify the components requesting a memory allocation.
+ * The tags can be used later to identify the total memory allocated to
+ * particular types of components.
+ */
+typedef enum
+{
+  /** tag None. */
+  NvBufferTag_NONE            = 0x0,
+  /** tag for Camera. */
+  NvBufferTag_CAMERA          = 0x200,
+  /** tag for Jpeg Encoder/Decoder. */
+  NvBufferTag_JPEG            = 0x1500,
+  /** tag for VPR Buffers. */
+  NvBufferTag_PROTECTED       = 0x1504,
+  /** tag for H264/H265 Video Encoder. */
+  NvBufferTag_VIDEO_ENC       = 0x1200,
+  /** tag for H264/H265/VP9 Video Decoder. */
+  NvBufferTag_VIDEO_DEC       = 0x1400,
+  /** tag for Video Transform/Composite. */
+  NvBufferTag_VIDEO_CONVERT   = 0xf01,
+} NvBufferTag;
+
+/**
+ * Defines color formats for NvBuffer.
+ */
+typedef enum
+{
+  /** BT.601 colorspace - YUV420 multi-planar. */
+  NvBufferColorFormat_YUV420      = 0,
+  /** BT.601 colorspace - YUV420 ER multi-planar. */
+  NvBufferColorFormat_YUV420_ER   = 2,  /* BSP 32.5.0 and up: 3 */
+  /** BT.601 colorspace - Y/CbCr 4:2:0 multi-planar. */
+  NvBufferColorFormat_NV12        = 4,  /* BSP 32.5.0 and up: 5 */
+  /** BT.601 colorspace - Y/CbCr ER 4:2:0 multi-planar. */
+  NvBufferColorFormat_NV12_ER     = 5,  /* BSP 32.5.0 and up: 6 */
+  /** LegacyRGBA colorspace - BGRA-8-8-8-8 planar. */
+  NvBufferColorFormat_ABGR32      = 16, /* BSP 32.5.0 and up: 17 */
+  /** LegacyRGBA colorspace - XRGB-8-8-8-8 planar. */
+  NvBufferColorFormat_XRGB32      = 17, /* BSP 32.5.0 and up: 18 */
+  /** LegacyRGBA colorspace - ARGB-8-8-8-8 planar. */
+  NvBufferColorFormat_ARGB32      = 18, /* BSP 32.5.0 and up: 19 */
+  /** BT.601 colorspace - Y/CbCr 4:2:0 10-bit multi-planar. */
+  NvBufferColorFormat_NV12_10LE   = 19, /* BSP 32.5.0 and up: 20 */
+  /** BT.709 colorspace - Y/CbCr 4:2:0 10-bit multi-planar. */
+  NvBufferColorFormat_NV12_10LE_709    = 20, /* BSP 32.5.0 and up: 21 */
+  /** BT.709_ER colorspace - Y/CbCr 4:2:0 10-bit multi-planar. */
+  NvBufferColorFormat_NV12_10LE_709_ER = 21, /* BSP 32.5.0 and up: 22 */
+  /** BT.2020 colorspace - Y/CbCr 4:2:0 10-bit multi-planar. */
+  NvBufferColorFormat_NV12_10LE_2020   = 22, /* BSP 32.5.0 and up: 23 */
+  /** BT.709 colorspace - Y/CbCr 4:2:0 multi-planar. */
+  NvBufferColorFormat_NV12_709    = 29, /* BSP 32.5.0 and up: 30 */
+  /** BT.709 colorspace - Y/CbCr ER 4:2:0 multi-planar. */
+  NvBufferColorFormat_NV12_709_ER = 30, /* BSP 32.5.0 and up: 31 */
+  /** BT.2020 colorspace - Y/CbCr 4:2:0 multi-planar. */
+  NvBufferColorFormat_NV12_2020   = 32, /* BSP 32.5.0 and up: 33 */
+  /** BT.601 colorspace - YUV444 multi-planar. */
+  NvBufferColorFormat_YUV444      = 35, /* BSP 32.5.0 and up: 36. BSP 34.1.0 and up: 34 */
+} NvBufferColorFormat;
+
+/**
+ * Defines video flip methods.
+ */
+typedef enum
+{
+  /** Video flip none. */
+  NvBufferTransform_None,
+  /** Video flip rotate 90 degree counter-clockwise. */
+  NvBufferTransform_Rotate90,
+  /** Video flip rotate 180 degree. */
+  NvBufferTransform_Rotate180,
+  /** Video flip rotate 270 degree counter-clockwise. */
+  NvBufferTransform_Rotate270,
+  /** Video flip with respect to X-axis. */
+  NvBufferTransform_FlipX,
+  /** Video flip with respect to Y-axis. */
+  NvBufferTransform_FlipY,
+  /** Video flip transpose. */
+  NvBufferTransform_Transpose,
+  /** Video flip inverse transpode. */
+  NvBufferTransform_InvTranspose,
+} NvBufferTransform_Flip;
+
+/**
+ * Defines transform video filter types.
+ */
+typedef enum
+{
+  /** transform filter nearest. */
+  NvBufferTransform_Filter_Nearest,
+  /** transform filter bilinear. */
+  NvBufferTransform_Filter_Bilinear,
+  /** transform filter 5 tap. */
+  NvBufferTransform_Filter_5_Tap,
+  /** transform filter 10 tap. */
+  NvBufferTransform_Filter_10_Tap,
+  /** transform filter smart. */
+  NvBufferTransform_Filter_Smart,
+  /** transform filter nicest. */
+  NvBufferTransform_Filter_Nicest,
+} NvBufferTransform_Filter;
+
+/**
+ * Defines flags to indicate for valid transform.
+ */
+typedef enum {
+  /** transform flag to crop source rectangle. */
+  NVBUFFER_TRANSFORM_CROP_SRC   = 1,
+  /** transform flag to crop destination rectangle. */
+  NVBUFFER_TRANSFORM_CROP_DST   = 1 << 1,
+  /** transform flag to set filter type. */
+  NVBUFFER_TRANSFORM_FILTER     = 1 << 2,
+  /** transform flag to set flip method. */
+  NVBUFFER_TRANSFORM_FLIP       = 1 << 3,
+} NvBufferTransform_Flag;
+
+/**
+ * Holds coordinates for a rectangle.
+ */
+typedef struct
+{
+  /** rectangle top. */
+  uint32_t top;
+  /** rectangle left. */
+  uint32_t left;
+  /** rectangle width. */
+  uint32_t width;
+  /** rectangle height. */
+  uint32_t height;
+}NvBufferRect;
+
+/**
+ * Holds an opaque NvBuffer session type required for parallel buffer
+ * tranformations and compositions. Operations using a single session are
+ * scheduled sequentially, after the previous operation finishes. Operations for
+ * multiple sessions are scheduled in parallel.
+ */
+typedef struct _NvBufferSession * NvBufferSession;
+
+
+/**
+ * Holds the input parameters for hardware buffer creation.
+ */
+typedef struct _NvBufferCreateParams
+{
+  /** width of the buffer. */
+  int32_t width;
+  /** height of the buffer. */
+  int32_t height;
+  /** payload type of the buffer. */
+  NvBufferPayloadType payloadType;
+  /** size of the memory.(Applicale for NvBufferPayload_MemHandle) */
+  int32_t memsize;
+  /** layout of the buffer. */
+  NvBufferLayout layout;
+  /** colorformat of the buffer. */
+  NvBufferColorFormat colorFormat;
+  /** tag to associate with the buffer. */
+  NvBufferTag nvbuf_tag;
+}NvBufferCreateParams;
+
+/**
+ * Holds parameters for a hardware buffer.
+ */
+typedef struct _NvBufferParams
+{
+  /** Holds the DMABUF FD of the hardware buffer. */
+  uint32_t dmabuf_fd;
+  /** pointer to hardware buffer memory. */
+  void *nv_buffer;
+  /** payload type of the buffer. */
+  NvBufferPayloadType payloadType;
+  /** size of the memory.(Applicale for NvBufferPayload_MemHandle) */
+  int32_t memsize;
+  /** size of hardware buffer. */
+  uint32_t nv_buffer_size;
+  /** video format type of hardware buffer. */
+  NvBufferColorFormat pixel_format;
+  /** number of planes of hardware buffer. */
+  uint32_t num_planes;
+  /** width of each planes of hardware buffer. */
+  uint32_t width[MAX_NUM_PLANES];
+  /** height of each planes of hardware buffer. */
+  uint32_t height[MAX_NUM_PLANES];
+  /** pitch of each planes of hardware buffer. */
+  uint32_t pitch[MAX_NUM_PLANES];
+  /** memory offset values of each video planes of hardware buffer. */
+  uint32_t offset[MAX_NUM_PLANES];
+  /** size of each video planes of hardware buffer. */
+  uint32_t psize[MAX_NUM_PLANES];
+  /** layout type of each planes of hardware buffer. */
+  uint32_t layout[MAX_NUM_PLANES];
+}NvBufferParams;
+
+/**
+ * Holds parameters for buffer transform functions.
+ */
+typedef struct _NvBufferTransformParams
+{
+  /** flag to indicate which of the transform parameters are valid. */
+  uint32_t transform_flag;
+  /** flip method. */
+  NvBufferTransform_Flip transform_flip;
+  /** transform filter. */
+  NvBufferTransform_Filter transform_filter;
+  /** source rectangle coordinates for crop opeartion. */
+  NvBufferRect src_rect;
+  /** destination rectangle coordinates for crop opeartion. */
+  NvBufferRect dst_rect;
+  /** NvBufferSession to be used for transform. If NULL, the default session
+   * is used. */
+  NvBufferSession session;
+}NvBufferTransformParams;
+
+/**
+ * Allocates a hardware buffer (deprecated).
+ *
+ * @deprecated Use NvBufferCreateEx() instead.
+ * @param[out] dmabuf_fd    Returns the DMABUF FD of the hardware buffer.
+ * @param[in]  width        Buffer width, in bytes.
+ * @param[in]  height       Buffer height, in bytes.
+ * @param[in]  layout       Layout of the buffer.
+ * @param[in]  colorFormat  Color format of the buffer.
+ *
+ * @return 0 if successful, or -1 otherwise.
+ */
+int NvBufferCreate (int *dmabuf_fd, int width, int height,
+    NvBufferLayout layout, NvBufferColorFormat colorFormat);
+
+/**
+ * Allocates a hardware buffer.
+ *
+ * @param[out] dmabuf_fd    Returns the DMABUF FD of the hardware buffer.
+ * @param[in]  input_params Input parameters for hardware buffer creation.
+ *
+ * @returns 0 for success, -1 for failure
+ */
+int NvBufferCreateEx (int *dmabuf_fd, NvBufferCreateParams *input_params);
+
+/**
+ * Gets buffer parameters.
+ * @param[in] dmabuf_fd `DMABUF FD` of buffer.
+ * @param[out] params A pointer to the structure to fill with parameters.
+ *
+ * @returns 0 for success, -1 for failure.
+ */
+int NvBufferGetParams (int dmabuf_fd, NvBufferParams *params);
+
+/**
+* Destroys a HW buffer.
+* @param[in] dmabuf_fd Specifies the `dmabuf_fd` `hw_buffer` to destroy.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int NvBufferDestroy (int dmabuf_fd);
+
+/**
+* Syncs the HW memory cache for the CPU.
+*
+* \sa NvBufferMemMap for the purpose of the function
+*
+* @param[in] dmabuf_fd DMABUF FD of buffer.
+* @param[in] plane video frame plane.
+* @param[in] pVirtAddr Virtual Address pointer of the memory-mapped plane.
+*
+* @returns 0 for success, -1 for failure.
+
+*/
+int NvBufferMemSyncForCpu (int dmabuf_fd, unsigned int plane, void **pVirtAddr);
+
+/**
+* Syncs the hardware memory cache for the device.
+*
+* \sa NvBufferMemMap for the purpose of the function
+*
+* @param[in] dmabuf_fd DMABUF FD of buffer.
+* @param[in] plane video frame plane.
+* @param[in] pVirtAddr Virtual Address pointer of the memory-mapped plane.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int NvBufferMemSyncForDevice (int dmabuf_fd, unsigned int plane, void **pVirtAddr);
+
+/**
+* Gets the memory-mapped virtual address of the plane.
+*
+* The client must call NvBufferMemSyncForCpu() with the virtual address returned
+* by this function before accessing the mapped memory in CPU.
+*
+* After memory mapping is complete, mapped memory modification
+* must be coordinated between the CPU and hardware device as
+* follows:
+* - CPU: If the CPU modifies any mapped memory, the client must call
+*   NvBufferMemSyncForDevice() before any hardware device accesses the memory.
+* - Hardware device: If the mapped memory is modified by any hardware device,
+*   the client must call NvBufferMemSyncForCpu() before CPU accesses the memory.
+*
+* @param[in] dmabuf_fd DMABUF FD of buffer.
+* @param[in] plane video frame plane.(Applies to @ref NvBufferPayload_SurfArray.)
+* @param[in] memflag NvBuffer memory flag.
+* @param[out] pVirtAddr Virtual Address pointer of the memory-mapped plane.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int NvBufferMemMap (int dmabuf_fd, unsigned int plane, NvBufferMemFlags memflag, void **pVirtAddr);
+
+/**
+* Unmaps the mapped virtual address of the plane.
+*
+* If the following conditions are both true, the client must call
+* NvBufferMemSyncForDevice() before unmapping the memory:
+* - Mapped memory was modified by the CPU.
+* - Mapped memory will be accessed by a hardware device.
+*
+* @param[in] dmabuf_fd  DMABUF FD of the buffer.
+* @param[in] plane      Video frame plane. Applies to
+*                       @ref NvBufferPayload_SurfArray.
+* @param[in] pVirtAddr  Virtual address pointer to the memory-mapped plane.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int NvBufferMemUnMap (int dmabuf_fd, unsigned int plane, void **pVirtAddr);
+
+/**
+* Copies the NvBuffer plane contents to a raw buffer plane.
+* @param[in] dmabuf_fd DMABUF FD of NvBuffer.
+* @param[in] plane video frame plane.
+* @param[in] out_width aligned width of the raw data plane.
+* @param[in] out_height aligned height of the raw data plane.
+* @param[in] ptr pointer to the output raw plane data.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int NvBuffer2Raw (int dmabuf_fd, unsigned int plane, unsigned int out_width, unsigned int out_height, unsigned char *ptr);
+
+/**
+* Copies raw buffer plane contents to an NvBuffer plane.
+* @param[in] ptr pointer to the input raw plane data.
+* @param[in] plane video frame plane.
+* @param[in] in_width aligned width of the raw data plane.
+* @param[in] in_height aligned height of the raw data plane.
+* @param[in] dmabuf_fd DMABUF FD of NvBuffer.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int Raw2NvBuffer (unsigned char *ptr, unsigned int plane, unsigned int in_width, unsigned int in_height, int dmabuf_fd);
+
+/**
+* Creates a new NvBufferSession for parallel scheduling of
+* buffer transformations and compositions.
+*
+* @returns A session pointer, NULL for failure.
+*/
+NvBufferSession NvBufferSessionCreate(void);
+
+/**
+* Destroys an existing \ref NvBufferSession.
+* @param[in] session    An existing NvBufferSession.
+*/
+void NvBufferSessionDestroy(NvBufferSession session);
+
+/**
+ * Transforms one DMA buffer to another DMA buffer.
+ * This function can support transforms for copying, scaling, fliping, rotating, and cropping.
+ * @param[in] src_dmabuf_fd DMABUF FD of source buffer
+ * @param[in] dst_dmabuf_fd DMABUF FD of destination buffer
+ * @param[in] transform_params transform parameters
+ *
+ * @return 0 for sucess, -1 for failure.
+ */
+int NvBufferTransform (int src_dmabuf_fd, int dst_dmabuf_fd, NvBufferTransformParams *transform_params);
+
+#endif /*__NVV4L2_EXT_UTILS_H__*/
-- 
2.40.1

